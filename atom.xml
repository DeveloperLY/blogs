<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DeveloperLY&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.developerly.net/"/>
  <updated>2019-07-18T14:09:10.273Z</updated>
  <id>http://blog.developerly.net/</id>
  
  <author>
    <name>DeveloperLY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Mac自动操作制作@1x@2x@3x图片（切图）</title>
    <link href="http://blog.developerly.net/2019/01/20/%E4%BD%BF%E7%94%A8Mac%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E5%88%B6%E4%BD%9C-1x-2x-3x%E5%9B%BE%E7%89%87%EF%BC%88%E5%88%87%E5%9B%BE%EF%BC%89/"/>
    <id>http://blog.developerly.net/2019/01/20/使用Mac自动操作制作-1x-2x-3x图片（切图）/</id>
    <published>2019-01-20T13:17:09.000Z</published>
    <updated>2019-07-18T14:09:10.273Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中，使用的图片要求导入@1x、@2x和@3x:</p><ul><li><p>使用@1x格式：iPhone3GS（基本上是淘汰了）</p></li><li><p>使用@2x格式：iPhone 4，4S，5，5S，5C，SE，6，6S，7，8，XR</p></li><li><p>使用@3x格式：iPhone 6Plus、6sPlus、7Plus、8Plus、X、XS、XS Max</p></li></ul><p>这样在开发过程中，将三种图片（比如分别为<code>【xxx.png】</code>、<code>【xxx@2x.png】</code> 和 <code>【xxx@3x.png】</code>）导入到工程图库中的时候可以自动被识别为1x、2x和3x大小的图片</p><a id="more"></a><p>可以利用Mac系统中自带的服务自己制作一个快速生成@1x、@2x和@3x图片的功能</p><p>首先<code>spotlight</code>搜索<code>Automator</code>，然后按<code>Enter</code>打开</p><p><img src="/images/20190120/Snip20190718_2.png" alt="Snip20190718_2.png"></p><p>新建文稿</p><p><img src="/images/20190120/Snip20190718_3.png" alt="Snip20190718_3.png"></p><p>选取文稿类型为<code>快速操作</code></p><p><img src="/images/20190120/Snip20190718_4.png" alt="Snip20190718_4.png"></p><p>在<code>工作流程收到当前</code>的后面选择<code>图像文件</code></p><p><img src="/images/20190120/Snip20190718_5.png" alt="Snip20190718_5.png"></p><p>在左边窗口的“<code>操作</code>”下，选择“<code>资源库</code>”中的“<code>文件和文件夹</code>”，将右侧中的“<code>给访达项目重新命名</code>”拖入最右侧的窗口中，（如果警告提示是否要增加一个“<code>拷贝访达项目</code>”操作，选择“<code>不添加</code>”），选择“<code>添加文本</code>”，在输入框中输入【<code>@3x</code>】</p><p><img src="/images/20190120/Snip20190718_6.png" alt="Snip20190718_6.png"></p><p>拖入“<code>复制访达项目</code>”</p><p><img src="/images/20190120/Snip20190718_7.png" alt="Snip20190718_7.png"></p><p>选择左侧“<code>资源库</code>”中的照片，将“<code>缩放图像</code>”拖入右侧窗口（如果警告提示是否要增加一个“<code>拷贝访达项目</code>”操作，选择“<code>不添加</code>”），并选择“<code>按百分比</code>”，输入【<code>66</code>】</p><p><img src="/images/20190120/Snip20190718_8.png" alt="Snip20190718_8.png"></p><p>再拖入“<code>文件和文件夹</code>”下的“<code>给访达项目重新命名</code>”，（如果警告提示是否要增加一个“<code>拷贝访达项目</code>”操作，选择“<code>不添加</code>”）并选择【<code>替换文本</code>】，查找【<code>“</code>】，以【<code>仅基本名称</code>】；再拖入“<code>文件和文件夹</code>”下的“<code>给访达项目重新命名</code>”，并选择【<code>替换文本</code>】，查找【<code>@3x”的副本</code>】，以【<code>仅基本名称</code>】，替换成【<code>@2x</code>】</p><p><img src="/images/20190120/Snip20190718_9.png" alt="Snip20190718_9.png"></p><p>拖入“<code>复制访达项目</code>”，选择左侧“<code>资源库</code>”中的照片，将“<code>缩放图像</code>”拖入右侧窗口（如果警告提示是否要增加一个“<code>拷贝访达项目</code>”操作，选择“<code>不添加</code>”），并选择“<code>按百分比</code>”，输入【<code>50</code>】</p><p><img src="/images/20190120/Snip20190718_10.png" alt="Snip20190718_10.png"></p><p>再拖入“<code>文件和文件夹</code>”下的“<code>给访达项目重新命名</code>”，（如果警告提示是否要增加一个“<code>拷贝访达项目</code>”操作，选择“<code>不添加</code>”）并选择【<code>替换文本</code>】，查找【<code>“</code>】，以【<code>仅基本名称</code>】，再拖入“<code>文件和文件夹</code>”下的“<code>给访达项目重新命名</code>”，并选择【<code>替换文本</code>】，查找【<code>@2x”的副本</code>】，以【<code>仅基本名称</code>】</p><p><img src="/images/20190120/Snip20190718_11.png" alt="Snip20190718_11.png"></p><p>然后保存，将“<code>快速操作</code>”存储为“<code>制作@2x@3x图片</code>”</p><p><img src="/images/20190120/Snip20190718_12.png" alt="Snip20190718_12.png"></p><p>每次使用的时候，只需选中图片，选择<code>访达 -&gt; 服务 -&gt; 制作@2x@3x图片</code>，就会自动生成三个图片：<code>【xxx.png】</code>、<code>【xxx@2x.png】</code>和<code>【xxx@3x.png】</code></p><p><img src="/images/20190120/Snip20190718_13.png" alt="Snip20190718_13.png"></p><p>或者选择图片，右键<code>服务 -&gt; 制作@2x@3x图片</code>一样会自动生成三个图片：<code>【xxx.png】</code>、<code>【xxx@2x.png】</code> 和 <code>【xxx@3x.png】</code></p><p><img src="/images/20190120/Snip20190718_14.png" alt="Snip20190718_14.png"></p><p>注意：这里3x的图片是当前图片，也就制作的原图就是3x的；</p><p>最终效果~</p><p><img src="/images/20190120/Snip20190718_15.png" alt="Snip20190718_15.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中，使用的图片要求导入@1x、@2x和@3x:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用@1x格式：iPhone3GS（基本上是淘汰了）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用@2x格式：iPhone 4，4S，5，5S，5C，SE，6，6S，7，8，XR&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用@3x格式：iPhone 6Plus、6sPlus、7Plus、8Plus、X、XS、XS Max&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样在开发过程中，将三种图片（比如分别为&lt;code&gt;【xxx.png】&lt;/code&gt;、&lt;code&gt;【xxx@2x.png】&lt;/code&gt; 和 &lt;code&gt;【xxx@3x.png】&lt;/code&gt;）导入到工程图库中的时候可以自动被识别为1x、2x和3x大小的图片&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="iOS开发" scheme="http://blog.developerly.net/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="UI" scheme="http://blog.developerly.net/tags/UI/"/>
    
      <category term="切图" scheme="http://blog.developerly.net/tags/%E5%88%87%E5%9B%BE/"/>
    
      <category term="自动操作" scheme="http://blog.developerly.net/tags/%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C/"/>
    
      <category term="Automator" scheme="http://blog.developerly.net/tags/Automator/"/>
    
  </entry>
  
  <entry>
    <title>TabBar 的 Item 按钮的像素大小</title>
    <link href="http://blog.developerly.net/2019/01/20/TabBar%20%E7%9A%84%20Item%20%E6%8C%89%E9%92%AE%E7%9A%84%E5%83%8F%E7%B4%A0%E5%A4%A7%E5%B0%8F/"/>
    <id>http://blog.developerly.net/2019/01/20/TabBar 的 Item 按钮的像素大小/</id>
    <published>2019-01-20T12:07:40.000Z</published>
    <updated>2019-07-18T12:33:31.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TabBar的Item按钮的像素大小要求"><a href="#TabBar的Item按钮的像素大小要求" class="headerlink" title="TabBar的Item按钮的像素大小要求"></a>TabBar的Item按钮的像素大小要求</h2><p>根据<a href="https://developer.apple.com/design/human-interface-guidelines/" target="_blank" rel="noopener">苹果官方人机界面指南（Human Interface Guidelines）</a>可以得知：</p><p>iOS系统会根据设备和方向显示两种标签栏：<code>常规（Regular）</code>和<code>紧凑（Compact）</code>，<br>所以在设置<code>自定义TabBar Item</code>的时候也应该包含常规和紧凑两种不同的尺寸～</p><p><code>根据图形是圆形、方形、宽形、高形</code>，像素也有不同的要求：</p><ul><li><p>如果图标是圆形的，应该提供：25pt@2x、25pt@3x、18pt@2x、18pt@3x</p></li><li><p>如果图标是方形的，应该提供：23pt@2x、23pt@3x、17pt@2x、17pt@3x</p></li></ul><a id="more"></a><ul><li><p>如果图标是宽形的，应该提供：31pt@2x、31pt@3x、23pt@2x、23pt@3x</p></li><li><p>如果图标是高形的，应该提供：28pt@2x、28pt@3x、20pt@2x、20pt@3x</p></li></ul><h2 id="完整表格"><a href="#完整表格" class="headerlink" title="完整表格~"></a>完整表格~</h2><p><img src="/images/20190120/Snip20190120_1.png" alt="Snip20190120_1.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TabBar的Item按钮的像素大小要求&quot;&gt;&lt;a href=&quot;#TabBar的Item按钮的像素大小要求&quot; class=&quot;headerlink&quot; title=&quot;TabBar的Item按钮的像素大小要求&quot;&gt;&lt;/a&gt;TabBar的Item按钮的像素大小要求&lt;/h2&gt;&lt;p&gt;根据&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苹果官方人机界面指南（Human Interface Guidelines）&lt;/a&gt;可以得知：&lt;/p&gt;
&lt;p&gt;iOS系统会根据设备和方向显示两种标签栏：&lt;code&gt;常规（Regular）&lt;/code&gt;和&lt;code&gt;紧凑（Compact）&lt;/code&gt;，&lt;br&gt;所以在设置&lt;code&gt;自定义TabBar Item&lt;/code&gt;的时候也应该包含常规和紧凑两种不同的尺寸～&lt;/p&gt;
&lt;p&gt;&lt;code&gt;根据图形是圆形、方形、宽形、高形&lt;/code&gt;，像素也有不同的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果图标是圆形的，应该提供：25pt@2x、25pt@3x、18pt@2x、18pt@3x&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果图标是方形的，应该提供：23pt@2x、23pt@3x、17pt@2x、17pt@3x&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="iOS开发" scheme="http://blog.developerly.net/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="UI" scheme="http://blog.developerly.net/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析</title>
    <link href="http://blog.developerly.net/2018/12/30/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://blog.developerly.net/2018/12/30/复杂度分析/</id>
    <published>2018-12-30T02:30:35.000Z</published>
    <updated>2018-12-25T12:18:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p><code>算法复杂度</code>是指算法在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和内存资源。应用于数学和计算机导论。</p><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从<code>时间复杂度</code>和<code>空间复杂度</code>来考虑。</p><p>学习数据结构和算法，就一定离不开时间、空间复杂度分析。复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。<br><a id="more"></a></p><h2 id="二、为什么需要复杂度分析"><a href="#二、为什么需要复杂度分析" class="headerlink" title="二、为什么需要复杂度分析"></a>二、为什么需要复杂度分析</h2><ol><li>预测算法所需要的资源<ul><li>计算时间（CPU消耗）</li><li>内存空间（RAM消耗）</li><li>通信时间（带宽消耗）</li></ul></li><li>预测算法的运行时间<ul><li>在给定输入规模时，所执行的基本操作数量</li><li>或者称之为算法复杂度（Algorithm Complexity）</li></ul></li><li>测试结果非常依赖测试环境<ul><li>测试环境中硬件的不同对测试结果有很大的影响</li></ul></li><li>测试结果受到数据规模的影响很大<ul><li>对于小规模的数据排序，插入排序可能反倒会比快速排序要快</li></ul></li></ol><p>所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。这就是时间、空间复杂度分析方法。</p><h2 id="三、大-O-复杂度表示法"><a href="#三、大-O-复杂度表示法" class="headerlink" title="三、大 O 复杂度表示法"></a>三、大 O 复杂度表示法</h2><p>大O表示法就是将算法的所有步骤转换为代数项，然后排除不会对问题的整体复杂度产生较大影响的较低阶常数和系数。</p><p>一起来估算下面的代码执行时间，求1，2，3…n的累加和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (; i &lt;= n; ++i) &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>CPU</code>的角度来看，这段代码的每一行都执行着类似的操作：<code>读数据-运算-写数据</code>。尽管每行代码对应的<code>CPU</code>执行的个数、执行的时间都不一样，但是，这里只是粗略的估计，所以可以假设每行代码执行的时间都一样，为 <code>unit_time</code>。在这个假设基础之上，这段代码的总执行时间是多少呢？<br>第 2、3 行代码分别需要1个<code>unit_time</code>的执行时间，第 4、5 行都运行了<code>n</code>遍，所以需要<code>2n * unit_time</code>的执行时间，所以这段代码总的执行时间就是<code>(2n + 2) * unit_time</code>。可以看出来，所有代码的执行时间<code>T(n)</code>与每行代码的执行次数成正比。</p><p>按照这个分析思路，再来看下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i = 1;</span><br><span class="line">    int j = 1;</span><br><span class="line">    for (; i &lt;= n; ++i) &#123;</span><br><span class="line">        j = 1;</span><br><span class="line">        for (; j &lt;= n; ++j) &#123;</span><br><span class="line">            sum = sum + j * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧假设每个语句的执行时间是<code>unit_time</code>。那这段代码的总执行时间<code>T(n)</code>是多少呢？<br>第 2、3、4 行代码，每行都需要 1 个 <code>unit_time</code> 执行时间，第 5、6 行代码循环执行了 <code>n</code> 遍，需要 <code>2n * unit_time</code> 的执行时间，第 7、8 行代码循环执行了 n<sup>2</sup> 遍，所以需要 2n<sup>2</sup> <em> unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n<sup>2</sup> + 2n + 3) </em> unit_time。</p><p>尽管不知道 <code>unit_time</code> 的具体值，但是通过上面两段代码的执行时间的推导过程，可以得到一个非常重要的规律，那就是：所有代码的执行时间 <code>T(n)</code> 与每行代码的执行次数 <code>n</code> 成正比。</p><p>这个规律总结成公式就是：</p><p> <img src="/images/20180930/%E5%A4%A7O%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="大O复杂度表示法"></p><ul><li><code>T(n)</code> 表示代码执行的时间；</li><li><code>n</code> 表示数据规模的大小；</li><li><code>f(n)</code> 表示每行代码执行的次数总和（因为是一个公式，所以用<code>f(n)</code>来表示）；</li><li><code>O</code> 表示代码的执行时间 <code>T(n)</code> 与 <code>f(n)</code> 表达式成正比；</li></ul><p>所以，第一个例子中的 T(n) = O(2n + 2)，第二个例子中的 T(n) = O(2n<sup>2</sup> + 2n + 3)。 这就是<code>大 O 时间复杂度表示法</code>。大 <code>O</code> 时间复杂度实际上并不具体表示<code>代码真正的执行时间，而是表示代码执行时间随着数据规模增长的变化趋势</code>，所以，也叫作<code>渐进时间复杂度（asymptotic time complexity）</code>，简称<code>时间复杂度</code>。</p><p>当 n 很大时，比如10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚才的两段代码的时间复杂度，就可以记为: T(n) = O(n)；T(n) = O(n<sup>2</sup>)。</p><h2 id="四、时间复杂度分析"><a href="#四、时间复杂度分析" class="headerlink" title="四、时间复杂度分析"></a>四、时间复杂度分析</h2><h3 id="1-只关注循环执行次数最多的一段代码"><a href="#1-只关注循环执行次数最多的一段代码" class="headerlink" title="1.只关注循环执行次数最多的一段代码"></a>1.只关注循环执行次数最多的一段代码</h3><p>刚才说了， 大 O 这种复杂度表示法只是表示一种变化趋势。通常会忽略掉公司中的常量、低价、系数，只需要记录一个最大阶量级就可以了，所有在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p><h3 id="2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2. 加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>2. 加法法则：总复杂度等于量级最大的那段代码的复杂度</h3><p>如果T1(n) = O(f(n))，T2(n) = O(g(n))；那么T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))。</p><h3 id="3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><p>如果 T1(n) = O(f(n))，T2(n) = O(g(n))；那么 T(n) = T1(n)<em>T2(n) = O(f(n))</em>O(g(n)) = O(f(n)<em>g(n))。<br>也就是说，假设 T1(n) = O(n), T2(n) = O(n<sup>2</sup>)，则T1(n) </em> T2(n) = O(n<sup>3</sup>)。</p><h2 id="五、几种常见时间复杂度实例分析"><a href="#五、几种常见时间复杂度实例分析" class="headerlink" title="五、几种常见时间复杂度实例分析"></a>五、几种常见时间复杂度实例分析</h2><p>虽然代码千差万别，但是常见的复杂度量级并不多。</p><p><img src="/images/20180930/%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%87%8F%E7%BA%A7.jpg" alt="复杂度量级"></p><p>上面罗列的复杂度量级，可以粗略的分为两类，<code>多项式量级</code>和<code>非多项式量级</code>。其中非多项式量级只有两个：O(2<sup>n</sup>) 和 O(n!)。</p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以非多项式时间复杂度的算法其实是非常低效的算法。</p><h3 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1. O(1)"></a>1. O(1)</h3><p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。即只要代码的执行时间不随着 n 的增大而增长，这样代码的时间复杂度都记作O(1)。或者说，<code>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)</code>。</p><p>比如：下面代码即便有三行，它的时间复杂度也是O(1)，而不是O(3)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">int j = 3;</span><br><span class="line">int sum = i + j;</span><br></pre></td></tr></table></figure><h3 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2. O(logn)、O(nlogn)"></a>2. O(logn)、O(nlogn)</h3><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1;</span><br><span class="line">while (i &lt;= n) &#123;</span><br><span class="line">    i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以知道，变量 i 的取值就是一个等比数列。</p><p><img src="/images/20180930/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97.jpg" alt="等比数列"></p><p>通过 2<sup>x</sup> = n 求解 x 的公式 x = log<sub>2</sub>n，所以这段代码的时间复杂度就是O(log<sub>2</sub>n)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1;</span><br><span class="line">while (i &lt;= n) &#123;</span><br><span class="line">    i = i * 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据刚才的思路，可以看出这段代码的时间复杂度为O(log<sub>3</sub>n)<br>实际上不管是以 2 为底、以 3 为底还是以 10 为底，都可以把对数阶的时间复杂度记为 O(logn)。<br>我们知道，对数之间是可以相互转换的，log<sub>3</sub>n 就等于 log<sub>3</sub>2 <em> log<sub>3</sub>n， 所以O(log<sub>3</sub>n) = O(C </em> log<sub>2</sub>n)，其中 C * log<sub>3</sub>2 是一个常量。基于<code>在采用大 O 标记复杂度的时候可以忽略系数，即 O(Cf(n)) = O(f(n))</code>。所以，O(log<sub>2</sub>n) 就等于 O(log<sub>3</sub>n)。因此，在对数阶时间复杂度的表示方法里，忽略对数的“底”，统一表示为 O(logn)。<br>O(nlogn)，如果一段代码的时间复杂度是 O(logn)，循环执行 n 遍，时间复杂度就变成 O(nlogn)了，而且 O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p><h3 id="3-O-m-n-、O-m-n"><a href="#3-O-m-n-、O-m-n" class="headerlink" title="3. O(m+n)、O(m*n)"></a>3. O(m+n)、O(m*n)</h3><p>再来看一种和前面不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">    int sum_1 = 0;</span><br><span class="line">    int i = 1;</span><br><span class="line">    for (; i &lt; m; ++i) &#123;</span><br><span class="line">        sum_1 = sum_1 + i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sum_2 = 0;</span><br><span class="line">    int j = 1;</span><br><span class="line">    for (; j &lt; n; ++i) &#123;</span><br><span class="line">        sum_2 = sum_2 + j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出， m 和 n 是表示两个数据的规模。无法事先评估 m 和 n 谁的量级大，所以在表示时间复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)。</p><p>针对这种情况，原来的加法法则就不正确了，我们需要将加法法则改为:T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m) <em> T2(n) = O(f(m) </em> g(n))。</p><h2 id="六、空间复杂度分析"><a href="#六、空间复杂度分析" class="headerlink" title="六、空间复杂度分析"></a>六、空间复杂度分析</h2><p><code>空间复杂度(Space Complexity)</code>是对一个算法在运行过程中临时占用存储空间大小的量度，记做<code>S(n)=O(f(n))</code>。比如直接插入排序的时间复杂度是<code>O(n^2)</code>,空间复杂度是<code>O(1)</code> 。而一般的递归算法就要有<code>O(n)</code>的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。</p><p>时间复杂度的全称是<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是<strong>渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系</strong>。</p><p>空间复杂度分析相比时间复杂度分析简单的多，而且常见的空间复杂度就是O(1)、O(n)、O(n<sup>2</sup>)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。<br>常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup>)。</p><p><img src="/images/20180930/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%BA%BF%E6%80%A7%E5%9B%BE.jpg" alt="时间复杂度线性图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h2&gt;&lt;p&gt;&lt;code&gt;算法复杂度&lt;/code&gt;是指算法在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和内存资源。应用于数学和计算机导论。&lt;/p&gt;
&lt;p&gt;同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从&lt;code&gt;时间复杂度&lt;/code&gt;和&lt;code&gt;空间复杂度&lt;/code&gt;来考虑。&lt;/p&gt;
&lt;p&gt;学习数据结构和算法，就一定离不开时间、空间复杂度分析。复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://blog.developerly.net/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.developerly.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="时间复杂度、空间复杂度" scheme="http://blog.developerly.net/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>算法和数据结构</title>
    <link href="http://blog.developerly.net/2018/12/30/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.developerly.net/2018/12/30/算法和数据结构/</id>
    <published>2018-12-30T02:00:50.000Z</published>
    <updated>2018-12-25T12:18:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构这门课程是大小计算机系的必修课，很多人第一次接触这门课时，都会觉的数据结构和算法很抽象，晦涩难懂，宛如天书。虽然在大学的时候老师讲的都听明白了，但是毕业后不是专门从事算法相关的工作。所以到现在已经忘记很多了。如果你想让自己的编程能力有质的飞跃，不再停留于调用现成的东西而是追求更完美的实现， 对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！那么数据结构和算法是你的必修课！<br><a id="more"></a></p><h2 id="一、什么是数据结构"><a href="#一、什么是数据结构" class="headerlink" title="一、什么是数据结构"></a>一、什么是数据结构</h2><p>官方定义:<br>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。</p><p>大部分数据结构和算法的教材，都会给这两个概念明确一下定义， 但是这些定义都很抽象，对理解这两个概念并没有实质性的帮助，反倒会让你陷入死抠定义的误区。<br>虽然我们说没必要深挖严格的定义，但是这并不等于不需要理解概念。</p><h3 id="广义上讲"><a href="#广义上讲" class="headerlink" title="广义上讲"></a>广义上讲</h3><p>数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p><h3 id="狭义上讲"><a href="#狭义上讲" class="headerlink" title="狭义上讲"></a>狭义上讲</h3><p>是指某些著名的数据结构和算法，比如队列、栈、二分查找、动态规划等。</p><h2 id="二、数据结构和算法的关系"><a href="#二、数据结构和算法的关系" class="headerlink" title="二、数据结构和算法的关系"></a>二、数据结构和算法的关系</h2><p>大部分的书和教程都会把数据结构和算法这两个东西放到一起讲，这是因为数据结构和算法是相辅相成的。<br>数据机构是为算法服务的，算法要作用在特定的数据结构之上。</p><p>比如，常用的二分查找算法需要用数组来存储数据，因为数组具有随机访问的特点。但是如果选用链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。</p><p>数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立的数据结构就是没有用的。</p><h2 id="数据结构和算法涵盖的内容"><a href="#数据结构和算法涵盖的内容" class="headerlink" title="数据结构和算法涵盖的内容"></a>数据结构和算法涵盖的内容</h2><p><img src="/images/20180930/数据结构和算法.jpg" alt="数据结构和算法"></p><p>20个最常用的、最基础的数据结构和算法：<br>10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；<br>10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</p><p>不管是应付面试还是工作需要，只要集中精力逐一攻克这 20 个知识点就足够了。而且掌握了这些基础的数据结构和算法，再去学更加复杂的数据结构和算法，就会非常容易、非常快。</p><p>学习数据结构和算法的过程，是非常好的思维训练的过程，所以，千万不要被动的记忆，要多辩证地思考，多问为什么。如果你一直这么坚持做，你会发现，等你学完之后，写代码的时候就会不由自主地考虑到很多性能方面的事情，时间复杂度、空间复杂度非常高的垃圾代码出现的次数就会越来越少。你的汇编内功就真正得到了修炼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构这门课程是大小计算机系的必修课，很多人第一次接触这门课时，都会觉的数据结构和算法很抽象，晦涩难懂，宛如天书。虽然在大学的时候老师讲的都听明白了，但是毕业后不是专门从事算法相关的工作。所以到现在已经忘记很多了。如果你想让自己的编程能力有质的飞跃，不再停留于调用现成的东西而是追求更完美的实现， 对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！那么数据结构和算法是你的必修课！&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://blog.developerly.net/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.developerly.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构和算法" scheme="http://blog.developerly.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://blog.developerly.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LLVM-Clang插件开发</title>
    <link href="http://blog.developerly.net/2018/09/13/LLVM-Clang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.developerly.net/2018/09/13/LLVM-Clang插件开发/</id>
    <published>2018-09-12T17:25:40.000Z</published>
    <updated>2018-09-21T19:16:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面一篇博客介绍了<code>LLVM</code>相关内容，那现在就开始用学到的<code>LLVM</code>知识，做一下实践；</p><p>–<code>Clang</code>插件开发</p><a id="more"></a><h2 id="一、插件目录"><a href="#一、插件目录" class="headerlink" title="一、插件目录"></a>一、插件目录</h2><ul><li><p>在【<code>clang/tools</code>】源码目录下新建一个插件目录，叫做【<code>ly-plugin</code>】(自定义)</p><p><img src="/images/20180913/Snip20180913_1.png" alt=""></p></li><li><p>在【<code>clang/tools/CMakeLists.txt</code>】最后加入内容： <code>add_clang_subdirectory(ly -plugin)</code>，小括号里是插件目录名</p><p><img src="/images/20180913/Snip20180913_2.png" alt=""></p></li></ul><h2 id="二、插件必要的文件"><a href="#二、插件必要的文件" class="headerlink" title="二、插件必要的文件"></a>二、插件必要的文件</h2><ul><li><p>在【<code>ly-plugin</code>】目录下新建一个【<code>CMakeLists.txt</code>】，文件内容是：<code>add_llvm_loadable_module(LYPlugin LYPlugin.cpp</code>)</p><p><img src="/images/20180913/Snip20180913_3.png" alt=""></p><p><img src="/images/20180913/Snip20180913_4.png" alt=""></p></li></ul><h2 id="三、编写插件源码"><a href="#三、编写插件源码" class="headerlink" title="三、编写插件源码"></a>三、编写插件源码</h2><ul><li><p>【<code>LYPlugin.cpp</code>】参考</p><p><img src="/images/20180913/Snip20180913_5.png" alt=""></p></li></ul><h2 id="四、编译插件"><a href="#四、编译插件" class="headerlink" title="四、编译插件"></a>四、编译插件</h2><ul><li>利用<code>cmake</code>生成的<code>Xcode</code>项目来编译插件（第一次编写完插件，需要利用<code>cmake</code>重新生成一下<code>Xcode</code>项目）</li><li>插件源代码在【<code>Sources/Loadable modules</code>】目录下可以找到，这样就可以直接在<code>Xcode</code>里编写插件代码</li><li><p>选择<code>LYPlugin</code>这个<code>target</code>进行编译，编译完会生成一个动态库文件</p><p><img src="/images/20180913/Snip20180913_6.png" alt=""></p><p><img src="/images/20180913/Snip20180913_7.png" alt=""></p><p><img src="/images/20180913/Snip20180913_8.png" alt=""></p></li></ul><h2 id="五、加载插件"><a href="#五、加载插件" class="headerlink" title="五、加载插件"></a>五、加载插件</h2><ul><li>在<code>Xcode</code>项目中指定加载插件动态库：<code>Build Settings &gt; OTHER_CFLAGS</code></li><li><p><code>-Xclang -load -Xclang</code> 动态库路径 <code>-Xclang -add-plugin -Xclang</code> 插件名称</p><p><img src="/images/20180913/Snip20180913_9.png" alt=""></p></li></ul><h2 id="六、Hack-Xcode"><a href="#六、Hack-Xcode" class="headerlink" title="六、Hack Xcode"></a>六、Hack Xcode</h2><ul><li>首先要对<code>Xcode</code>进行<code>Hack</code>，才能修改默认的编译器</li><li><p>下载【<a href="https://pan.baidu.com/s/12mG4Ozp8L-Ry4IIPMf1ZJg" target="_blank" rel="noopener">XcodeHacking.zip</a>】，解压，修改【<code>HackedClang.xcplugin/Contents/Resources/HackedClang.xcspec</code>】的内容，设置一下自己编译好的<code>clang</code>的路径</p><p><img src="/images/20180913/Snip20180913_10.png" alt=""></p></li><li><p>然后在<code>XcodeHacking</code>目录下进行命令行，将<code>XcodeHacking</code>的内容剪切到<code>Xcode</code>内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv HackedClang.xcplugin `xcode-select-printpath`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv HackedBuildSystem.xcspec `xcode-select-printpath`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications</span><br></pre></td></tr></table></figure></li></ul><h2 id="七、修改Xcode的编译器"><a href="#七、修改Xcode的编译器" class="headerlink" title="七、修改Xcode的编译器"></a>七、修改Xcode的编译器</h2><p><img src="/images/20180913/Snip20180913_11.png" alt=""></p><h2 id="八、编译项目"><a href="#八、编译项目" class="headerlink" title="八、编译项目"></a>八、编译项目</h2><ul><li><p>编译项目后，会在编译日志看到<code>LYPlugin</code>插件的打印信息（如果插件更新了，最好先<code>Clean</code>一下项目）</p><p><img src="/images/20180913/Snip20180913_12.png" alt=""></p></li></ul><h2 id="九、更多"><a href="#九、更多" class="headerlink" title="九、更多"></a>九、更多</h2><ul><li><p>想要实现更复杂的插件功能，就需要利用<code>clang</code>的<code>API</code>针对语法树（<code>AST</code>）进行相应的分析和处理</p></li><li><p>关于AST的资料</p><ul><li><a href="https://clang.llvm.org/doxygen/namespaceclang.html" target="_blank" rel="noopener">https://clang.llvm.org/doxygen/namespaceclang.html</a></li><li><a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html" target="_blank" rel="noopener">https://clang.llvm.org/doxygen/classclang_1_1Decl.html</a></li><li><a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html" target="_blank" rel="noopener">https://clang.llvm.org/doxygen/classclang_1_1Stmt.html</a></li></ul></li></ul><h2 id="十、推荐书籍"><a href="#十、推荐书籍" class="headerlink" title="十、推荐书籍"></a>十、推荐书籍</h2><p><img src="/images/20180913/Snip20180913_13.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面一篇博客介绍了&lt;code&gt;LLVM&lt;/code&gt;相关内容，那现在就开始用学到的&lt;code&gt;LLVM&lt;/code&gt;知识，做一下实践；&lt;/p&gt;
&lt;p&gt;–&lt;code&gt;Clang&lt;/code&gt;插件开发&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="LLVM" scheme="http://blog.developerly.net/tags/LLVM/"/>
    
      <category term="Clang" scheme="http://blog.developerly.net/tags/Clang/"/>
    
      <category term="插件开发" scheme="http://blog.developerly.net/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="编译器" scheme="http://blog.developerly.net/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>LLVM</title>
    <link href="http://blog.developerly.net/2018/09/12/LLVM/"/>
    <id>http://blog.developerly.net/2018/09/12/LLVM/</id>
    <published>2018-09-12T14:28:48.000Z</published>
    <updated>2018-09-16T11:35:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是LLVM？"><a href="#一、什么是LLVM？" class="headerlink" title="一、什么是LLVM？"></a>一、什么是LLVM？</h2><p><img src="/images/20180912/Snip20180912_1.png" alt=""></p><ul><li>官网：<a href="https://llvm.org/" target="_blank" rel="noopener">https://llvm.org/</a></li><li>The <code>LLVM</code> Project is a collection of modular and reusable <code>compiler</code> and <code>toolchain</code> technologies.<br>（<code>LLVM</code>项目是模块化、可重用的<code>编译器</code>以及工具<code>链技术</code>的集合。）</li><li>美国计算机协会 (ACM) 将其<code>2012</code>年软件系统奖项颁给了<code>LLVM</code>，之前曾经获得此奖项的软件和技术包括：<code>Java</code>、<code>Apache</code>、 <code>Mosaic</code>、<code>the World Wide Web</code>、<code>Smalltalk</code>、<code>UNIX</code>、<code>Eclipse</code>等等<a id="more"></a></li><li>创始人<code>Chris Lattner</code>，亦是<code>Swift</code>之父;</li><li>有些文章把<code>LLVM</code>当做<code>Low Level Virtual Machine</code>（低级虚拟机）的缩写简称，官方描述如下:<code>The name &quot;LLVM&quot; itself is not an acronym; it is the full name of the project.</code>(<code>LLVM</code>这个名称本身不是首字母缩略词; 它是项目的全名)</li></ul><h2 id="二、传统的编译器架构和LLVM架构"><a href="#二、传统的编译器架构和LLVM架构" class="headerlink" title="二、传统的编译器架构和LLVM架构"></a>二、传统的编译器架构和LLVM架构</h2><p><img src="/images/20180912/Snip20180912_2.png" alt=""><br><img src="/images/20180912/Snip20180912_3.png" alt=""></p><ul><li>不同的前端后端使用统一的中间代码<code>LLVM Intermediate Representation</code>(<code>LLVM IR</code>) </li><li>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</li><li>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端 </li><li>优化阶段是一个通用的阶段，它针对的是统一的<code>LLVM IR</code>，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改</li><li>相比之下，<code>GCC</code>的前端和后端没分得太开，前端后端耦合在了一起。所以<code>GCC</code>为了支持一门新的语言，或者为了支持一个新的目标平台，就变得特别困难 </li><li><code>LLVM</code>现在被作为实现各种静态和运行时编译语言的通用基础结构（<code>GCC</code>家族、<code>Java</code>、<code>.NET</code>、<code>Python</code>、<code>Ruby</code>、<code>Scheme</code>、<code>Haskell</code>、<code>D</code>等）</li></ul><h2 id="三、Clang"><a href="#三、Clang" class="headerlink" title="三、Clang"></a>三、Clang</h2><ul><li><p>什么是<code>Clang</code>？ </p><ul><li><code>LLVM</code>项目的一个子项目 </li><li>基于<code>LLVM</code>架构的<code>C/C++/Objective-C</code>编译器前端 </li><li>官网：<a href="http://clang.llvm.org/" target="_blank" rel="noopener">http://clang.llvm.org/</a></li></ul></li><li><p>相比于<code>GCC</code>，<code>Clang</code>具有如下优点 </p><ul><li>编译速度快：在某些平台上，<code>Clang</code>的编译速度显著的快过<code>GCC</code>（<code>Debug</code>模式下编译<code>OC</code>速度比<code>GGC</code>快<code>3倍</code>）</li><li>占用内存小：<code>Clang</code>生成的<code>AST</code>所占用的内存是<code>GCC</code>的五分之一左右 </li><li>模块化设计：<code>Clang</code>采用基于库的模块化设计，易于<code>IDE</code>集成及其他用途的重用 </li><li>诊断信息可读性强：在编译过程中，<code>Clang</code>创建并保留了大量详细的元数据 (<code>metadata</code>)，有利于调试和错误报告 </li><li>设计清晰简单，容易理解，易于扩展增强</li></ul></li></ul><h2 id="四、Clang与LLVM"><a href="#四、Clang与LLVM" class="headerlink" title="四、Clang与LLVM"></a>四、Clang与LLVM</h2><p> <img src="/images/20180912/Snip20180912_5.png" alt=""></p><h2 id="五、OC源文件的编译过程"><a href="#五、OC源文件的编译过程" class="headerlink" title="五、OC源文件的编译过程"></a>五、OC源文件的编译过程</h2><ul><li>命令行查看编译的过程：<code>$ clang -ccc-print-phases main.m</code><br><img src="/images/20180912/Snip20180912_6.png" alt=""></li><li>查看<code>preprocessor</code>（预处理）的结果：<code>$ clang -E main.m</code></li></ul><h2 id="六、词法分析"><a href="#六、词法分析" class="headerlink" title="六、词法分析"></a>六、词法分析</h2><ul><li><p>词法分析，生成<code>Token</code>： <code>$ clang -fmodules -E -Xclang -dump-tokens main.m</code></p><p><img src="/images/20180912/Snip20180912_7.png" alt=""><br><img src="/images/20180912/Snip20180912_8.png" alt=""></p><h2 id="七、语法树-AST"><a href="#七、语法树-AST" class="headerlink" title="七、语法树-AST"></a>七、语法树-AST</h2></li><li>语法分析，生成语法树（<code>AST</code>，<code>Abstract Syntax Tree</code>）：<code>$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></li></ul><p><img src="/images/20180912/Snip20180912_9.png" alt=""><br><img src="/images/20180912/Snip20180912_10.png" alt=""></p><h2 id="八、LLVM-IR"><a href="#八、LLVM-IR" class="headerlink" title="八、LLVM IR"></a>八、LLVM IR</h2><ul><li><code>LLVM IR</code>有3种表示形式（但本质是等价的，就好比水可以有气体、液体、固体3种形态）<ul><li><code>text</code>：便于阅读的文本格式，类似于汇编语言，拓展名<code>.ll</code>， <code>$ clang -S -emit-llvm main.m</code> </li><li><code>memory</code>：内存格式 </li><li><code>bitcode</code>：二进制格式，拓展名<code>.bc</code>， <code>$ clang -c -emit-llvm main.m</code></li></ul></li></ul><p><img src="/images/20180912/Snip20180912_11.png" alt=""></p><ul><li>IR基本语法<ul><li>注释以分号 <code>;</code> 开头 </li><li>全局标识符以<code>@</code>开头，局部标识符以<code>%</code>开头 </li><li><code>alloca</code>，在当前函数栈帧中分配内存 </li><li><code>i32</code>，<code>32bit</code>，4个字节的意思 </li><li><code>align</code>，内存对齐 </li><li><code>store</code>，写入数据 </li><li><code>load</code>，读取数据</li></ul></li><li>官方语法参考 <ul><li><a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">https://llvm.org/docs/LangRef.html</a></li></ul></li></ul><h2 id="九、源码下载"><a href="#九、源码下载" class="headerlink" title="九、源码下载"></a>九、源码下载</h2><ul><li><p>下载LLVM </p><ul><li><code>$ git clone https://git.llvm.org/git/llvm.git/</code></li><li>大小<code>746.2 MB</code>，仅供参考</li></ul></li><li><p>下载clang</p><ul><li><code>$ cd llvm/tools</code></li><li><code>$ git clone https://git.llvm.org/git/clang.git/</code> </li><li>大小<code>297.7 MB</code>，仅供参考</li></ul></li></ul><h2 id="十、源码编译"><a href="#十、源码编译" class="headerlink" title="十、源码编译"></a>十、源码编译</h2><ul><li><p>安装<code>cmake</code>和<code>ninja</code>（先安装<code>brew</code>，<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a>） </p><ul><li><code>$ brew install cmake</code></li><li><code>$ brew install ninja</code></li></ul></li><li><p><code>ninja</code>如果安装失败，可以直接从<code>github</code>获取<code>release</code>版放入<code>【/usr/local/bin】</code>中 </p><ul><li><a href="https://github.com/ninja-build/ninja/releases" target="_blank" rel="noopener">https://github.com/ninja-build/ninja/releases</a></li></ul></li><li><p>在LLVM源码同级目录下新建一个<code>【llvm_build】</code>目录（最终会在<code>【llvm_build】</code>目录下生成<code>【build.ninja】</code>） </p><ul><li><code>$ cd llvm_build</code></li><li><code>$ cmake -G Ninja ../llvm -DCMAKE_INSTALL_PREFIX=LLVM的安装路径</code> </li><li>更多<code>cmake</code>相关选项，可以参考：<a href="https://llvm.org/docs/CMake.html" target="_blank" rel="noopener">https://llvm.org/docs/CMake.html</a></li></ul></li><li><p>依次执行编译、安装指令 </p><ul><li><code>$ ninja</code></li><li>编译完毕后，<code>【llvm_build】</code>目录大概<code>21.05 G</code>（仅供参考） </li><li><code>$ ninja install</code> </li><li>安装完毕后，安装目录大概<code>11.92 G</code>（仅供参考）</li></ul></li><li>也可以生成<code>Xcode</code>项目再进行编译，但是速度很慢（可能需要1个多小时）</li><li>在<code>llvm</code>同级目录下新建一个<code>【llvm_xcode】</code>目录<ul><li><code>cd llvm_xcode</code> </li><li><code>$ cmake -G Xcode ../llvm</code></li></ul></li></ul><p><img src="/images/20180912/Snip20180912_12.png" alt=""><br><img src="/images/20180912/Snip20180912_13.png" alt=""><br><img src="/images/20180912/Snip20180912_14.png" alt=""></p><h2 id="十一、应用与实践"><a href="#十一、应用与实践" class="headerlink" title="十一、应用与实践"></a>十一、应用与实践</h2><ul><li><p><code>libclang</code>、<code>libTooling</code> </p><ul><li>官方参考：<a href="https://clang.llvm.org/docs/Tooling.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/Tooling.html</a> </li><li>应用：语法树分析、语言转换等</li></ul></li><li><p><code>Clang</code>插件开发 </p><ul><li>官方参考<ul><li><a href="https://clang.llvm.org/docs/ClangPlugins.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/ClangPlugins.html</a> </li><li><a href="https://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/ExternalClangExamples.html</a> </li><li><a href="https://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/RAVFrontendAction.html</a> </li></ul></li><li>应用：代码检查（命名规范、代码规范）等</li></ul></li><li><p><code>Pass</code>开发 p</p><ul><li>官方参考：<a href="https://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">https://llvm.org/docs/WritingAnLLVMPass.html</a> </li><li>应用：代码优化、代码混淆等</li></ul></li><li><p>开发新的编程语言 </p><ul><li><a href="https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html</a> </li><li><a href="https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是LLVM？&quot;&gt;&lt;a href=&quot;#一、什么是LLVM？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是LLVM？&quot;&gt;&lt;/a&gt;一、什么是LLVM？&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/20180912/Snip20180912_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官网：&lt;a href=&quot;https://llvm.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://llvm.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;LLVM&lt;/code&gt; Project is a collection of modular and reusable &lt;code&gt;compiler&lt;/code&gt; and &lt;code&gt;toolchain&lt;/code&gt; technologies.&lt;br&gt;（&lt;code&gt;LLVM&lt;/code&gt;项目是模块化、可重用的&lt;code&gt;编译器&lt;/code&gt;以及工具&lt;code&gt;链技术&lt;/code&gt;的集合。）&lt;/li&gt;
&lt;li&gt;美国计算机协会 (ACM) 将其&lt;code&gt;2012&lt;/code&gt;年软件系统奖项颁给了&lt;code&gt;LLVM&lt;/code&gt;，之前曾经获得此奖项的软件和技术包括：&lt;code&gt;Java&lt;/code&gt;、&lt;code&gt;Apache&lt;/code&gt;、 &lt;code&gt;Mosaic&lt;/code&gt;、&lt;code&gt;the World Wide Web&lt;/code&gt;、&lt;code&gt;Smalltalk&lt;/code&gt;、&lt;code&gt;UNIX&lt;/code&gt;、&lt;code&gt;Eclipse&lt;/code&gt;等等
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="LLVM" scheme="http://blog.developerly.net/tags/LLVM/"/>
    
      <category term="编译器" scheme="http://blog.developerly.net/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods私有库使用Tips</title>
    <link href="http://blog.developerly.net/2017/09/11/CocoaPods%E7%A7%81%E6%9C%89%E5%BA%93%E4%BD%BF%E7%94%A8Tips/"/>
    <id>http://blog.developerly.net/2017/09/11/CocoaPods私有库使用Tips/</id>
    <published>2017-09-11T15:15:15.000Z</published>
    <updated>2017-09-11T15:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-pod-lib-lint-和-pod-spec-lint-命令的区别"><a href="#1-pod-lib-lint-和-pod-spec-lint-命令的区别" class="headerlink" title="1.pod lib lint 和 pod spec lint 命令的区别"></a>1.<code>pod lib lint</code> 和 <code>pod spec lint</code> 命令的区别</h2><ul><li><code>pod lib lint</code>是只从本地验证你的pod能否通过验证;</li><li><code>pod spec lint</code>是从本地和远程验证你的pod能否通过验证;</li></ul><h2 id="2-私有pod的验证"><a href="#2-私有pod的验证" class="headerlink" title="2.私有pod的验证"></a>2.私有<code>pod</code>的验证</h2><p>使用<code>pod spec lint</code>去验证私有库能否通过验证时应该要添加<code>--sources</code>选项，不然会出现找不到<code>repo</code>的错误:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint --sources=<span class="string">'私有仓库repo地址,https://github.com/CocoaPods/Specs'</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="3-subspec"><a href="#3-subspec" class="headerlink" title="3.subspec"></a>3.<code>subspec</code></h2><p>为了让自己的<code>Pod</code>被导入时显示出良好的文件层划分，<code>subspec</code>是必须的。<br>若<code>subspec</code>要依赖其它的<code>subspec</code>，则<code>subspec</code>的<code>dependency</code>后面接的不是目录路径，而是<code>specA/specB</code>这种<code>spec</code>关系；</p><h2 id="4-私有库引用私有库的问题"><a href="#4-私有库引用私有库的问题" class="headerlink" title="4.私有库引用私有库的问题"></a>4.私有库引用私有库的问题</h2><p>在私有库引用了私有库的情况下，在验证和推送私有库的情况下都要加上所有的资源地址，不然<code>Pod</code>会默认从官方<code>repo</code>查询。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint --sources=<span class="string">'私有仓库repo地址,https://github.com/CocoaPods/Specs'</span></span><br><span class="line">pod repo push 本地repo名 podspec名 --sources=<span class="string">'私有仓库repo地址,https://github.com/CocoaPods/Specs</span></span><br></pre></td></tr></table></figure><h2 id="5-引用自己或第三方的framework或-a文件时"><a href="#5-引用自己或第三方的framework或-a文件时" class="headerlink" title="5.引用自己或第三方的framework或.a文件时"></a>5.引用自己或第三方的<code>framework</code>或<code>.a</code>文件时</h2><p>在<code>podsepc</code>中应该这样写:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.ios.vendored_frameworks = <span class="string">"xxx/**/*.framework"</span></span><br><span class="line">s.ios.vendored_libraries = <span class="string">"xxx/**/*.a”</span></span><br></pre></td></tr></table></figure><h2 id="6-引用静态库：-ios-library。去掉头尾的lib，用”-”分割"><a href="#6-引用静态库：-ios-library。去掉头尾的lib，用”-”分割" class="headerlink" title="6.引用静态库：(.ios).library。去掉头尾的lib，用”,”分割"></a>6.引用静态库：<code>(.ios).library</code>。去掉头尾的<code>lib</code>，用”<code>,</code>”分割</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/ 引用libxml2.lib和libz.lib.</span></span><br><span class="line"><span class="regexp">spec.libraries =  'xml2', 'z'</span></span><br></pre></td></tr></table></figure><h2 id="7-引用公有framework：-ios-framework-用”-”分割-去掉尾部的”-framework”"><a href="#7-引用公有framework：-ios-framework-用”-”分割-去掉尾部的”-framework”" class="headerlink" title="7.引用公有framework：(.ios).framework. 用”,”分割. 去掉尾部的”.framework”"></a>7.引用公有framework：<code>(.ios).framework</code>. 用”<code>,</code>”分割. 去掉尾部的”<code>.framework</code>”</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.frameworks = <span class="string">'UIKit'</span>,<span class="string">'SystemConfiguration'</span>, <span class="string">'Accelerate'</span></span><br></pre></td></tr></table></figure><h2 id="8-引用自己生成的framework：-ios-vendored-frameworks。用”-”分割-路径写从-podspec所在目录为根目录的相对路径-ps-这个不要省略-framework"><a href="#8-引用自己生成的framework：-ios-vendored-frameworks。用”-”分割-路径写从-podspec所在目录为根目录的相对路径-ps-这个不要省略-framework" class="headerlink" title="8.引用自己生成的framework：(.ios).vendored_frameworks。用”,”分割,路径写从.podspec所在目录为根目录的相对路径 ps:这个不要省略.framework"></a>8.引用自己生成的framework：<code>(.ios).vendored_frameworks</code>。用”<code>,</code>”分割,路径写从<code>.podspec</code>所在目录为根目录的相对路径 ps:这个不要省略<code>.framework</code></h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.ios.vendored_frameworks = <span class="string">'Pod/Assets/*.framework'</span></span><br></pre></td></tr></table></figure><h2 id="9-引用自己生成的-a文件-添加到Pod-Assets文件夹里-Demo的Example文件夹里也需要添加一下-不然找不到"><a href="#9-引用自己生成的-a文件-添加到Pod-Assets文件夹里-Demo的Example文件夹里也需要添加一下-不然找不到" class="headerlink" title="9.引用自己生成的.a文件, 添加到Pod/Assets文件夹里. Demo的Example文件夹里也需要添加一下, 不然找不到"></a>9.引用自己生成的<code>.a</code>文件, 添加到<code>Pod/Assets</code>文件夹里. Demo的Example文件夹里也需要添加一下, 不然找不到</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.ios.vendored_libraries = <span class="string">'Pod/Assets/*.a'</span></span><br></pre></td></tr></table></figure><p>在提交到私有仓库的时候需要加上<code>--use-libraries</code></p><h2 id="10-私有库中添加资源-图片、音视频等"><a href="#10-私有库中添加资源-图片、音视频等" class="headerlink" title="10.私有库中添加资源(图片、音视频等)"></a>10.私有库中添加资源(图片、音视频等)</h2><p>方法共有三种:</p><ul><li>第一种</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.resources = [<span class="string">"Images/*.png"</span>, <span class="string">"Sounds/*"</span>]</span><br></pre></td></tr></table></figure><p>但是这些资源会在打包的时候直接拷贝的<code>App</code>的<code>Bundle</code>中，这样说不定会和其它资源产生命名冲突；</p><ul><li>第二种</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.resource = <span class="string">"Resources/MyLibrary.bundle"</span></span><br></pre></td></tr></table></figure><p> 把资源都放在<code>bundle</code>中，然后打包时候这个<code>bundle</code>会直接拷贝进<code>App</code>的<code>mainBundle</code>中。使用的时候在<code>mainBundle</code>中查找这个<code>bundle</code>然后再搜索具体资源:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL *bundleURL = [[NSBundle mainBundle] URLForResource:@&quot;MyLibrary&quot; withExtension:@&quot;bundle&quot;];</span><br><span class="line">NSBundle *bundle = [NSBundle bundleWithURL:bundleURL];</span><br><span class="line">UIImage *imgage = [UIImage imageNamed:icon inBundle:bundle compatibleWithTraitCollection:nil];</span><br></pre></td></tr></table></figure><ul><li>第三种</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spec.resource_bundles = &#123;</span><br><span class="line"><span class="string">'MyLibrary'</span> =&gt; [<span class="string">'Resources/*.png'</span>],</span><br><span class="line"><span class="string">'OtherResources'</span> =&gt; [<span class="string">'OtherResources/*.png'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这种方法利用<code>framework</code>的命名空间，有效防止了资源冲突。<br>使用方法是先拿到最外面的<code>bundle</code>，然后再去找下面指定名字的<code>bundle</code> 对象，再搜索具体资源:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSBundle *bundle = [NSBundle bundleForClass:[self class]];</span><br><span class="line">NSURL *bundleURL = [bundle URLForResource:@&quot;MyLibrary&quot; withExtension:@&quot;bundle&quot;];</span><br><span class="line">NSBundle *resourceBundle = [NSBundle bundleWithURL: bundleURL];</span><br><span class="line">UIImage *imgage = [UIImage imageNamed:icon inBundle:resourceBundle compatibleWithTraitCollection:nil];</span><br></pre></td></tr></table></figure><h2 id="11-如果私有库添加了静态库或者dependency用了静态库"><a href="#11-如果私有库添加了静态库或者dependency用了静态库" class="headerlink" title="11.如果私有库添加了静态库或者dependency用了静态库"></a>11.如果私有库添加了静态库或者<code>dependency</code>用了静态库</h2><p>那么执行<code>pod lib lint</code>还有<code>pod spec lint</code>时候需要加上<code>—user-libraries</code>选项,否则会出现<code>&#39;The &#39;Pods&#39; target has transitive dependencies</code>错误</p><h2 id="12-如果私有库只引用其他库的subspec"><a href="#12-如果私有库只引用其他库的subspec" class="headerlink" title="12.如果私有库只引用其他库的subspec"></a>12.如果私有库只引用其他库的<code>subspec</code></h2><p>只需要依赖想依赖的<code>subspec</code>，不用管主<code>spec</code>（因为依赖<code>subspec</code>必然要依赖主<code>spec</code>）</p><h2 id="13-私有库已经通过验证并传到私有repo也能通过pod-search，但是就是pod-install失败"><a href="#13-私有库已经通过验证并传到私有repo也能通过pod-search，但是就是pod-install失败" class="headerlink" title="13.私有库已经通过验证并传到私有repo也能通过pod search，但是就是pod install失败"></a>13.私有库已经通过验证并传到私有<code>repo</code>也能通过<code>pod search</code>，但是就是<code>pod install</code>失败</h2><p>这时候只要执行<code>pod update</code></p><h2 id="14-提交到私有仓库的之前可以先验证一下-有问题就修复它-验证过了在提交"><a href="#14-提交到私有仓库的之前可以先验证一下-有问题就修复它-验证过了在提交" class="headerlink" title="14.提交到私有仓库的之前可以先验证一下, 有问题就修复它, 验证过了在提交"></a>14.提交到私有仓库的之前可以先验证一下, 有问题就修复它, 验证过了在提交</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint VenderName.podspec --verbose</span><br></pre></td></tr></table></figure><p>打好<code>tag</code>, 推到<code>Git</code>里去后, 才可以在测试的项目里的<code>Podfile</code>里引用这个库, 然后<code>pod update VenderName --no-repo-update</code>, 测试通过了, 在提交到私有仓库里</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'VenderName'</span>, <span class="symbol">:podspec</span> =&gt; <span class="string">'VenderName.podspec的路径地址'</span></span><br></pre></td></tr></table></figure><p>还可以指定引用某个分支的代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'VenderName'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'https://git.coding.net/CodingZero/VenderName.git'</span>, <span class="symbol">:branch</span> =&gt; <span class="string">'develop'</span></span><br></pre></td></tr></table></figure><p>提交到私有仓库的时候还可以忽略警告类的错误, 愣是要提交. 在后面加上<code>--allow-warnings</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push LYSpecs VenderName.podspec --allow-warnings</span><br></pre></td></tr></table></figure><p>如果有添加新的文件, 需要更新下引索, <code>Demo</code>里才可以识别</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update VenderName --no-repo-update</span><br></pre></td></tr></table></figure><h2 id="15-使用的时候还可以通过直接指定地址-tag-or-分支-or-commit-的方式来引入-这样就可以不用走发布流程了-也不需要添加源了"><a href="#15-使用的时候还可以通过直接指定地址-tag-or-分支-or-commit-的方式来引入-这样就可以不用走发布流程了-也不需要添加源了" class="headerlink" title="15.使用的时候还可以通过直接指定地址 + tag or 分支 or commit 的方式来引入, 这样就可以不用走发布流程了. 也不需要添加源了."></a>15.使用的时候还可以通过直接指定地址 + <code>tag</code> or <code>分支</code> or <code>commit</code> 的方式来引入, 这样就可以不用走发布流程了. 也不需要添加源了.</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'VenderName'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'https://git.coding.net/CodingZero/VenderName.git'</span>, <span class="symbol">:tag</span> =&gt; <span class="string">'0.8.1'</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'VenderName'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'https://git.coding.net/CodingZero/VenderName.git'</span>, <span class="symbol">:branch</span> =&gt; <span class="string">'develop'</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'VenderName'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'https://git.coding.net/CodingZero/VenderName.git'</span>, <span class="symbol">:commit</span> =&gt; <span class="string">'0812fe81319af2411233'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-pod-lib-lint-和-pod-spec-lint-命令的区别&quot;&gt;&lt;a href=&quot;#1-pod-lib-lint-和-pod-spec-lint-命令的区别&quot; class=&quot;headerlink&quot; title=&quot;1.pod lib lint 和 pod spec lint 命令的区别&quot;&gt;&lt;/a&gt;1.&lt;code&gt;pod lib lint&lt;/code&gt; 和 &lt;code&gt;pod spec lint&lt;/code&gt; 命令的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pod lib lint&lt;/code&gt;是只从本地验证你的pod能否通过验证;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pod spec lint&lt;/code&gt;是从本地和远程验证你的pod能否通过验证;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-私有pod的验证&quot;&gt;&lt;a href=&quot;#2-私有pod的验证&quot; class=&quot;headerlink&quot; title=&quot;2.私有pod的验证&quot;&gt;&lt;/a&gt;2.私有&lt;code&gt;pod&lt;/code&gt;的验证&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;pod spec lint&lt;/code&gt;去验证私有库能否通过验证时应该要添加&lt;code&gt;--sources&lt;/code&gt;选项，不然会出现找不到&lt;code&gt;repo&lt;/code&gt;的错误:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod spec lint --sources=&lt;span class=&quot;string&quot;&gt;&#39;私有仓库repo地址,https://github.com/CocoaPods/Specs&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="CocoaPods" scheme="http://blog.developerly.net/tags/CocoaPods/"/>
    
      <category term="pod" scheme="http://blog.developerly.net/tags/pod/"/>
    
      <category term="私有库" scheme="http://blog.developerly.net/tags/%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods私有库Steps</title>
    <link href="http://blog.developerly.net/2017/09/11/CocoaPods%E7%A7%81%E6%9C%89%E5%BA%93Steps/"/>
    <id>http://blog.developerly.net/2017/09/11/CocoaPods私有库Steps/</id>
    <published>2017-09-11T13:37:49.000Z</published>
    <updated>2017-12-25T13:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-创建私有仓库"><a href="#1-创建私有仓库" class="headerlink" title="1.创建私有仓库"></a>1.创建私有仓库</h2><p>先<code>coding.net</code>、<code>OSChina</code>、<code>GitHub</code>或者自己搭建的<code>Git</code>服务器上创建一个私有仓库，然后在本地添加仓库</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add LYSpecs <span class="symbol">https:</span>/<span class="regexp">/git.coding.net/</span>CodingZero/LYSpecs.git</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-创建私有库"><a href="#2-创建私有库" class="headerlink" title="2.创建私有库"></a>2.创建私有库</h2><p>创建私有库模板</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create VenderName</span><br></pre></td></tr></table></figure><ul><li><p>第一个问题是问你选择<code>Swift</code>还是<code>Objc</code>构建项目。<code>eg: ObjC</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hat language <span class="keyword">do</span> you want to use?? [ Swift / ObjC ]</span><br><span class="line"> &gt; ObjC</span><br></pre></td></tr></table></figure></li><li><p>第二个问题问你是否需要创建一个Demo项目<code>eg: Yes</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Would you like to <span class="keyword">include</span> a demo application with your library? [ Yes / No ]</span><br><span class="line"> &gt; Yes</span><br></pre></td></tr></table></figure></li><li><p>第三个问题让你是否选择一个测试框架<code>eg: None</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line">&gt; None</span><br></pre></td></tr></table></figure></li><li><p>第四个问题是否基于View测试<code>eg: No</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Would you like to <span class="keyword">do</span> view based testing? [ Yes / No ]</span><br><span class="line">&gt; No</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>第五个问题是询问 类的前缀<code>eg: LY</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">What is your <span class="class"><span class="keyword">class</span> <span class="title">prefix?</span></span></span><br><span class="line">&gt; LY</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-更新发布私有库"><a href="#3-更新发布私有库" class="headerlink" title="3.更新发布私有库"></a>3.更新发布私有库</h2><ul><li><p>提交代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A &amp;&amp; git commit -m <span class="string">"Release 1.0.0"</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>打<code>tag</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag <span class="string">'1.0.0'</span></span><br></pre></td></tr></table></figure></li><li><p>把<code>tag</code>推到远程仓库</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --tags</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>将本地的<code>master</code>分支推送到远程仓库</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>提交到私有仓库</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> pod repo push LYSpecs VenderName.podspec --allow-warnings --verbose</span><br><span class="line">/<span class="regexp">/ --allow-warnings : 允许 警告，有一些警告是代码自身带的。</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ --use-libraries  : 私有库、静态库引用的时候加上</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ —-verbose ： lint显示详情</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-使用私有库"><a href="#4-使用私有库" class="headerlink" title="4.使用私有库"></a>4.使用私有库</h2><ul><li><p>用的时候需要在<code>Podfile</code>里添加源</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> /<span class="regexp">/ GitHub地址</span></span><br><span class="line"><span class="regexp">source 'https:/</span><span class="regexp">/github.com/</span>CocoaPods/Specs.git<span class="string">'</span></span><br><span class="line"><span class="string"># ...相关库</span></span><br><span class="line"><span class="string">// 私有库地址</span></span><br><span class="line"><span class="string">source '</span><span class="symbol">https:</span>/<span class="regexp">/git.coding.net/</span>CodingZero/LYSpecs.git<span class="string">'</span></span><br><span class="line"><span class="string"># ...私有库</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>用的时候在Podfile里引用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'VenderName'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>开发模式下测试Pod库的代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'VenderName'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../'</span> <span class="comment"># 指定路径</span></span><br></pre></td></tr></table></figure><p>然后在Example工程目录下执行<code>pod update</code>命令安装依赖，打开项目工程，可以看到库文件都被加载到<code>Pods</code>子项目中了<br>不过它们并没有在<code>Pods</code>目录下，而是跟测试项目一样存在于<code>Development Pods/VenderName</code>中，这是因为我们是在本地测试，而没有把<code>podspec</code>文件添加到<code>Spec Repo</code>中的缘故。</p></li></ul><h2 id="5-podspec文件配置说明"><a href="#5-podspec文件配置说明" class="headerlink" title="5.podspec文件配置说明"></a>5.<code>podspec</code>文件配置说明</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to run `pod lib lint VenderName.podspec' to ensure this is a</span></span><br><span class="line"><span class="comment"># valid spec before submitting.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Any lines starting with a # are optional, but their use is encouraged</span></span><br><span class="line"><span class="comment"># To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">  <span class="comment">#名称</span></span><br><span class="line">  s.name             = <span class="string">'VenderName'</span></span><br><span class="line">  <span class="comment">#版本号</span></span><br><span class="line">  s.version          = <span class="string">'0.1.0'</span></span><br><span class="line">  <span class="comment">#简介</span></span><br><span class="line">  s.summary          = <span class="string">'这个是我的私有库项目Demo.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This description is used to generate tags and improve search results.</span></span><br><span class="line"><span class="comment">#   * Think: What does it do? Why did you write it? What is the focus?</span></span><br><span class="line"><span class="comment">#   * Try to keep it short, snappy and to the point.</span></span><br><span class="line"><span class="comment">#   * Write the description between the DESC delimiters below.</span></span><br><span class="line"><span class="comment">#   * Finally, don't worry about the indent, CocoaPods strips it!</span></span><br><span class="line"></span><br><span class="line">  s.description      = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">  这个是教程的 私有库项目 学习Demo. （主要：比s.summary要长）</span></span><br><span class="line"><span class="string">                       DESC</span></span><br><span class="line">  <span class="comment">#主页,这里要填写可以访问到的地址，不然验证不通过</span></span><br><span class="line">  s.homepage         = <span class="string">'https://coding.net/CodingZero/VenderName'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.screenshots     = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#开源协议</span></span><br><span class="line"></span><br><span class="line">  s.license          =   &#123; <span class="symbol">:type</span> =&gt; <span class="string">'MIT'</span>, <span class="symbol">:file</span> =&gt; <span class="string">'LICENSE'</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#作者</span></span><br><span class="line">  s.author           = &#123; <span class="string">'DeveloperLY'</span> =&gt; <span class="string">'coderyliu@gmail.com'</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS。</span></span><br><span class="line">  <span class="comment">#这里的s.source须指向存放源代码的链接地址，而不是托管spec文件的repo地址</span></span><br><span class="line">  s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">'https://coding.net/CodingZero/VenderName.git'</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"0.1.0"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#s.social_media_url = 'http://weibo.com/lycoder'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#支持的平台及版本</span></span><br><span class="line">  s.ios.deployment_target = <span class="string">'7.0'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则</span></span><br><span class="line">  <span class="comment">#用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span></span><br><span class="line"></span><br><span class="line">  s.source_files = <span class="string">"VenderName/Classes/**/*"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#资源文件地址</span></span><br><span class="line">  <span class="comment"># s.resource_bundles = &#123;</span></span><br><span class="line">  <span class="comment">#   'MyLib' =&gt; ['VenderName/Assets/*.png']</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#公开头文件地址</span></span><br><span class="line">  <span class="comment">#s.public_header_files = 'VenderName/Classes/**/*.h'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#所需的framework，多个用逗号隔开</span></span><br><span class="line">  s.frameworks = <span class="string">'UIKit'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span></span><br><span class="line">  <span class="comment"># s.dependency 'AFNetworking', '~&gt; 2.3'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-创建私有仓库&quot;&gt;&lt;a href=&quot;#1-创建私有仓库&quot; class=&quot;headerlink&quot; title=&quot;1.创建私有仓库&quot;&gt;&lt;/a&gt;1.创建私有仓库&lt;/h2&gt;&lt;p&gt;先&lt;code&gt;coding.net&lt;/code&gt;、&lt;code&gt;OSChina&lt;/code&gt;、&lt;code&gt;GitHub&lt;/code&gt;或者自己搭建的&lt;code&gt;Git&lt;/code&gt;服务器上创建一个私有仓库，然后在本地添加仓库&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod repo add LYSpecs &lt;span class=&quot;symbol&quot;&gt;https:&lt;/span&gt;/&lt;span class=&quot;regexp&quot;&gt;/git.coding.net/&lt;/span&gt;CodingZero/LYSpecs.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="CocoaPods" scheme="http://blog.developerly.net/tags/CocoaPods/"/>
    
      <category term="pod" scheme="http://blog.developerly.net/tags/pod/"/>
    
      <category term="私有库" scheme="http://blog.developerly.net/tags/%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 快速入门</title>
    <link href="http://blog.developerly.net/2017/09/09/SpringBoot-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://blog.developerly.net/2017/09/09/SpringBoot-快速入门/</id>
    <published>2017-09-09T14:26:28.000Z</published>
    <updated>2017-12-18T19:05:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>Spring Boot</code>是由<code>Pivotal</code>团队提供的全新框架，其设计目的是用来简化新<code>Spring</code>应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，<code>Spring Boot</code>致力于在蓬勃发展的快速应用开发领域<code>（rapid application development）</code>成为领导者。</p><a id="more"></a><h2 id="二、Spring-Boot-的主要优点："><a href="#二、Spring-Boot-的主要优点：" class="headerlink" title="二、Spring Boot 的主要优点："></a>二、Spring Boot 的主要优点：</h2><ul><li>快速构建独立的<code>Spring</code>应用程序</li><li>开箱即用，提供各种默认配置来简化项目配置</li><li>内嵌式容器简化<code>Web</code>项目，嵌入<code>Tomcat</code>、<code>Gradle</code>，无需部署<code>WAR</code>包</li><li>提供生产就绪功能，如指标，健康检查和外部配置</li><li>简化<code>Maven</code>及<code>Gradle</code>配置</li><li>没有冗余代码生成和XML配置的要求</li><li>对主流开发框架和工具链做无配置集成</li></ul><h2 id="三、系统环境"><a href="#三、系统环境" class="headerlink" title="三、系统环境"></a>三、系统环境</h2><ul><li>Java             1.8.0_112</li><li>Spring Boot        1.5.4</li><li>IntelliJ IDEA  2017.1.3</li></ul><h2 id="四、快速构建项目"><a href="#四、快速构建项目" class="headerlink" title="四、快速构建项目"></a>四、快速构建项目</h2><h3 id="1-使用SPRING-INITIALIZR工具生成基础项目"><a href="#1-使用SPRING-INITIALIZR工具生成基础项目" class="headerlink" title="1. 使用SPRING INITIALIZR工具生成基础项目"></a>1. 使用<code>SPRING INITIALIZR</code>工具生成基础项目</h3><p>1.1 打开浏览器：<code>http://start.spring.io/</code></p><p>1.2 选择构建工具<code>Maven Project</code>、<code>Java</code>和<code>Spring Boot</code>版本<code>1.5.4</code>以及填 写一下工程基本信息：<br><img src="/images/20170706/Snip20170706_1.png" alt="SPRING INITIALIZR"></p><p>1.3 点击<code>Generate Project</code>下载项目压缩包</p><h3 id="2-使用IDEA将解压的项目包以Maven方式导入"><a href="#2-使用IDEA将解压的项目包以Maven方式导入" class="headerlink" title="2. 使用IDEA将解压的项目包以Maven方式导入"></a>2. 使用<code>IDEA</code>将解压的项目包以<code>Maven</code>方式导入</h3><p>2.1 解压刚才下载的项目压缩包</p><p>2.2 打开<code>IDEA</code>在菜单中选择<code>File</code> -&gt; <code>New</code> -&gt; <code>Project from Existing Sources...</code></p><p>2.3 选择解压的项目文件夹，点击<code>Opne</code></p><p>2.4 点击<code>Import project from external model</code>并选择<code>Maven</code>，点击<code>Finish</code>到底为止。</p><h2 id="五、基础项目结构解析"><a href="#五、基础项目结构解析" class="headerlink" title="五、基础项目结构解析"></a>五、基础项目结构解析</h2><p><img src="/images/20170706/Snip20170706_2.png" alt="基础项目结构"></p><p>通过上述步骤构建了基础项目，如上图所示：</p><ul><li><code>src/main/java</code>下的程序入口：<code>SpringBootDemoApplication</code></li><li><code>src/main/resources</code>下的配置文件：<code>application.properties</code></li><li><code>src/test/</code>下的测试入口：<code>SpringBootDemoApplicationTests</code></li></ul><p>生成的<code>SpringBootDemoApplication</code>和<code>SpringBootDemoApplicationTests</code>类都可以直接运行来启动当前创建的项目，由于目前该项目未配合任何数据访问或<code>Web</code>模块，程序会在加载完<code>Spring</code>之后结束运行。</p><h2 id="六、引入Web模块"><a href="#六、引入Web模块" class="headerlink" title="六、引入Web模块"></a>六、引入Web模块</h2><p>当前的<code>pom.xml</code>内容如下，仅引入了两个模块：<br></p><ul><li><code>spring-boot-starter</code>：核心模块，包括自动配置支持、日志和YAML</li><li><code>spring-boot-starter-test</code>：测试模块，包括<code>JUnit</code>、<code>Hamcrest</code>、<code>Mockito</code><br></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入Web模块，需添加<code>spring-boot-starter-web</code>模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="七、编写Hello-World服务"><a href="#七、编写Hello-World服务" class="headerlink" title="七、编写Hello World服务"></a>七、编写Hello World服务</h2><ul><li>创建<code>package</code>命名为<code>net.developerly.web</code>（根据实际情况修改）</li><li>创建<code>ExampleController</code>类，内容如下 <br></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动主程序，打开浏览器访问<code>http://localhost:8080/hello</code>，可以看到页面输出<code>Hello World</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt;是由&lt;code&gt;Pivotal&lt;/code&gt;团队提供的全新框架，其设计目的是用来简化新&lt;code&gt;Spring&lt;/code&gt;应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，&lt;code&gt;Spring Boot&lt;/code&gt;致力于在蓬勃发展的快速应用开发领域&lt;code&gt;（rapid application development）&lt;/code&gt;成为领导者。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.developerly.net/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.developerly.net/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://blog.developerly.net/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目工程中启动Unity项目工程</title>
    <link href="http://blog.developerly.net/2016/08/30/iOS%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E4%B8%AD%E5%90%AF%E5%8A%A8Unity%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B/"/>
    <id>http://blog.developerly.net/2016/08/30/iOS项目工程中启动Unity项目工程/</id>
    <published>2016-08-30T14:36:05.000Z</published>
    <updated>2017-12-18T19:05:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Unity-3D导出iOS项目"><a href="#一、Unity-3D导出iOS项目" class="headerlink" title="一、Unity 3D导出iOS项目"></a>一、Unity 3D导出iOS项目</h2><ul><li>将Unity3D 导出 iOS的项目<ul><li>详细步骤…</li><li>导出目录<br><br><img src="/images/20160830/0000001.jpg" alt="Unity导出iOS目录"><br><br></li></ul></li><li>注）U3D的所有相关设置，都在U3D这边设置，设置好后导出iOS项目<br><br><a id="more"></a></li></ul><h2 id="二、将导出的一些文件导入到已有的iOS工程项目中"><a href="#二、将导出的一些文件导入到已有的iOS工程项目中" class="headerlink" title="二、将导出的一些文件导入到已有的iOS工程项目中"></a>二、将导出的一些文件导入到已有的iOS工程项目中</h2><ul><li>将<code>Classes</code> 和 <code>Libraries</code> 文件夹 选择 <code>Create groups</code> 方式导入已有的iOS工程中<br><br>  <img src="/images/20160830/Snip20160830_2.png" alt="导入Classes和Libraries"><br><br></li><li>将<code>Data</code> 文件夹 选择 <code>Create folder references</code> 方式导入的已有的iOS工程中<br><br>  <img src="/images/20160830/Snip20160830_3.png" alt="导入Data"><br><br></li><li>导入之后的目录结构<br><br>  <img src="/images/20160830/Snip20160830_4.png" alt="导入之后的目录"><br><br><h2 id="三、删除Native下所有的-h文件的引用"><a href="#三、删除Native下所有的-h文件的引用" class="headerlink" title="三、删除Native下所有的.h文件的引用"></a>三、删除Native下所有的.h文件的引用</h2>注意：<code>Native</code> 下面不仅有<code>.h</code>文件，还有<code>.cpp</code>文件，这里只需要删除所有的<code>.h</code>文件<br><br><br><img src="/images/20160830/Snip20160830_5.png" alt="删除Native下所有的.h文件的引用"><br><br><br><img src="/images/20160830/Snip20160830_6.png" alt="删除Native下所有的.h文件的引用"><br><br><h2 id="四、删除libil2cpp引用"><a href="#四、删除libil2cpp引用" class="headerlink" title="四、删除libil2cpp引用"></a>四、删除libil2cpp引用</h2><br><br><img src="/images/20160830/Snip20160830_9.png" alt="删除libil2cpp引用"><br><br><br><img src="/images/20160830/Snip20160830_6.png" alt="删除libil2cpp引用"><br><br><h2 id="五、添加引用类库"><a href="#五、添加引用类库" class="headerlink" title="五、添加引用类库"></a>五、添加引用类库</h2></li><li>添加引用库（有部分是iOS），有三个是<code>optional</code> ~<br><br><img src="/images/20160830/Snip20160830_7.png" alt="添加引用库"><br><br><h2 id="六、Build-Settings"><a href="#六、Build-Settings" class="headerlink" title="六、Build Settings"></a>六、Build Settings</h2></li><li><code>Build Options</code> -&gt; <code>Enable Bitcode</code> = <code>NO</code><br><br>  <img src="/images/20160830/Snip20160830_1.png" alt="Build Settings"><br><br></li><li><code>Linking</code> -&gt; <code>Other Linker Flags</code> 添加<code>-weak_framework</code> <code>CoreMotion</code> <code>-weak-lSystem</code><br><br>  <img src="/images/20160830/Snip20160830_11.png" alt="Build Settings"><br><br></li><li>在<code>Search Paths</code>-&gt;<code>Header Search Paths</code>添加下图中的头文件引用<br><br>  <img src="/images/20160830/Snip20160830_12.png" alt="Build Settings"><br><br></li><li>在<code>Search Paths</code>-&gt;<code>Library Search Paths</code> 添加图中路径<br><br>  <img src="/images/20160830/Snip20160830_13.png" alt="Build Settings"><br><br></li><li>在<code>Apple LLVM 7.1 - Custom Compiler Flags</code> -&gt; <code>Other C Flags</code> 中添加 <code>-DINIT_SCRIPTING_BACKEND=1</code> 同时会在 <code>Other C++ Flags</code>中出现<br><br>  <img src="/images/20160830/Snip20160830_14.png" alt="Build Settings"><br><br></li><li>修改<code>Apple LLVM 7.1 - Language</code> -&gt; <code>C Language Dialect</code> 值改为C99<br><br>  <img src="/images/20160830/Snip20160830_15.png" alt="Build Settings"><br><br></li><li>修改<code>Apple LLVM 7.1 - Language</code> -&gt; <code>Precompile Prefix Header</code> 的值为Yes<br><br>  <img src="/images/20160830/Snip20160830_16.png" alt="Build Settings"><br><br></li><li>在<code>Apple LLVM 7.1 - Language - C++</code>中做如下设置<br><br><br>  <img src="/images/20160830/Snip20160830_17.png" alt="Build Settings"><br><br></li><li>在<code>Apple LLVM 7.1 - Warnings - Objective C</code>中做如下更改<br><br><br>  <img src="/images/20160830/Snip20160830_18.png" alt="Build Settings"><br><br></li><li>在<code>User-Defined</code> 中添加如下<ul><li><code>GCC_THUMB_SUPPORT</code> = <code>NO</code></li><li><code>GCC_USE_INDIRECT_FUNCTION_CALLS</code> = <code>NO</code></li><li><code>UNITY_RUNTIME_VERSION</code> = <code>5.4.0f3</code></li><li><code>UNITY_SCRIPTING_BACKEND</code> = <code>il2cpp</code><br><br><br><img src="/images/20160830/Snip20160830_8.png" alt="Build Settings"><br><br><h2 id="七、修改PCH文件"><a href="#七、修改PCH文件" class="headerlink" title="七、修改PCH文件"></a>七、修改PCH文件</h2></li></ul></li><li>将<code>Unity</code>-&gt;<code>Classes</code>下面的<code>Perfix.pch</code>中的代码全部拷贝到主工程项目的<code>PCH</code>中，并且在主工程项目的<code>PCH</code>中添加 <code>#import &quot;UnityAppController.h&quot;</code><br><br><br>  <img src="/images/20160830/Snip20160830_10.png" alt="修改PCH文件"><br><br><br>  <img src="/images/20160830/Snip20160830_19.png" alt="修改PCH文件"><br><br></li></ul><h2 id="八、处理主工程和Unity的main文件"><a href="#八、处理主工程和Unity的main文件" class="headerlink" title="八、处理主工程和Unity的main文件"></a>八、处理主工程和Unity的<code>main</code>文件</h2><ul><li>处理iOS主工程中的<code>main.m</code>文件，将 <code>.m</code> 改为 <code>.mm</code></li><li>将<code>Unity</code>下<code>Classes</code>下的<code>main.mm</code>文件中的内容拷贝到主工程的<code>main</code>文件中，并进行如下修改：<br><br><img src="/images/20160830/Snip20160830_20.png" alt="处理主工程和Unity的`main`文件"><br></li><li>在<code>Build Phases</code>中移除<code>Unity</code>-&gt;<code>Classes</code>下的<code>main.mm</code>文件<br><br><h2 id="九、处理UnityAppController-h文件"><a href="#九、处理UnityAppController-h文件" class="headerlink" title="九、处理UnityAppController.h文件"></a>九、处理<code>UnityAppController.h</code>文件</h2><code>UnityAppController.h</code>做如下修改<br><br>  <img src="/images/20160830/Snip20160830_21.png" alt="处理`UnityAppController.h`文件"><br></li></ul><h2 id="十、处理AppDelegate这个类"><a href="#十、处理AppDelegate这个类" class="headerlink" title="十、处理AppDelegate这个类"></a>十、处理<code>AppDelegate</code>这个类</h2><ul><li>在<code>AppDelegate.h</code>中做如下修改<br><br> <img src="/images/20160830/Snip20160830_22.png" alt="处理`AppDelegate`这个类"><br><br></li><li>在<code>AppDelegate.m</code>中做如下修改<br><br>  <img src="/images/20160830/Snip20160830_23.png" alt="处理`AppDelegate`这个类"><br><br><br>  <img src="/images/20160830/Snip20160830_24.png" alt="处理`AppDelegate`这个类"><br><br><br>  <img src="/images/20160830/Snip20160830_25.png" alt="处理`AppDelegate`这个类"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Unity-3D导出iOS项目&quot;&gt;&lt;a href=&quot;#一、Unity-3D导出iOS项目&quot; class=&quot;headerlink&quot; title=&quot;一、Unity 3D导出iOS项目&quot;&gt;&lt;/a&gt;一、Unity 3D导出iOS项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将Unity3D 导出 iOS的项目&lt;ul&gt;
&lt;li&gt;详细步骤…&lt;/li&gt;
&lt;li&gt;导出目录&lt;br&gt;&lt;br&gt;&lt;img src=&quot;/images/20160830/0000001.jpg&quot; alt=&quot;Unity导出iOS目录&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注）U3D的所有相关设置，都在U3D这边设置，设置好后导出iOS项目&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.developerly.net/tags/iOS/"/>
    
      <category term="U3D" scheme="http://blog.developerly.net/tags/U3D/"/>
    
      <category term="Unity 3D" scheme="http://blog.developerly.net/tags/Unity-3D/"/>
    
      <category term="Unity" scheme="http://blog.developerly.net/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>搭建IPv6本地环境测试App</title>
    <link href="http://blog.developerly.net/2016/05/31/%E6%90%AD%E5%BB%BAIPv6%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95App/"/>
    <id>http://blog.developerly.net/2016/05/31/搭建IPv6本地环境测试App/</id>
    <published>2016-05-31T14:23:19.000Z</published>
    <updated>2017-12-25T15:46:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近有很多人都在关注支持<code>IPv6</code>的事情，果然是苹果打个哈欠，<code>iOS</code>行业内就得起一次风暴呀。自从5月初<code>Apple</code>明文规定所有开发者在6月1号以后提交新版本必须需要支持<code>IPv6-Only</code>的网络。</p><h2 id="二、IPv6-Only支持是什么？"><a href="#二、IPv6-Only支持是什么？" class="headerlink" title="二、IPv6-Only支持是什么？"></a>二、<code>IPv6-Only</code>支持是什么？</h2><p><code>IPv6</code>是对<code>IPv4</code>地址空间的扩充，<code>IPv4</code>和<code>IPv6</code>的区别就是<code>IP</code>地址前者是<code>.</code>（<code>dot</code>）分割，后者是以<code>:</code>冒号）分割的（更多详细信息自行搜索）。<a id="more"></a><br>目前当我们的<code>iOS</code>设备连接上<code>WiFi</code>、<code>4G</code>、<code>3G</code>等网络时，设备被分配的地址均是<code>IPv4</code>，但是随着运营商和企业逐渐部署<code>IPv6 DNS64/NAT64</code>网络之后，设备被分配的地址会变成<code>IPv6</code>的地址，而这些网络就是所谓的<code>IPv6-Only</code>网络，并且仍然可以通过此网络去获取<code>IPv4</code>地址提供的内容。客户端向服务器端请求域名解析，首先通过<code>DNS64 Server</code>查询<code>IPv6</code>的地址，如果查询不到，再向<code>DNS Server</code>查询<code>IPv4</code>地址，通过<code>DNS64 Server</code>合成一个<code>IPv6</code>的地址，最终将一个<code>IPv6</code>的地址返回给客户端。</p><p>如图所示：</p><p><img src="/images/20160531/Snip20160531_0.png" alt="Snip20160531_0"></p><h2 id="三、搭建IPv6环境测试你的APP"><a href="#三、搭建IPv6环境测试你的APP" class="headerlink" title="三、搭建IPv6环境测试你的APP"></a>三、搭建<code>IPv6</code>环境测试你的<code>APP</code></h2><p>在<code>Mac OS 10.11＋</code>的双网卡的<code>Mac</code>机器（以太网口＋无线网卡），我们可以通过模拟构建这么一个<code>local IPv6 DNS64/NAT64</code>的网络环境去测试应用是否支持<code>IPv6-Only</code>网络，大概原理如下：</p><p><img src="/images/20160531/Snip20160531_1.png" alt="Snip20160531_1"></p><p>搭建<code>IPv6</code>测试环境说白了就是用<code>Mac</code>做一个热点，然后用<code>iPhone</code>连接这个<code>Wi-Fi</code>，听起来很容易，下面跟着我的步伐走吧。（非<code>WiFi</code>上网方式的<code>Mac</code>）<br>和正常的开启<code>Mac</code>热点的方式的区别是这次我们产生的是一个本地的<code>IPv6 DNS64/NAT64</code>网络，这项功能是<code>OS X 10.11</code>新加的功能（如果你的<code>Mac</code>系统版本不是的话必须要升级哦，才能产生<code>IPv6</code>的热点）。<br>和我们以前开启热点方式不一样的地方在于，我们在<code>系统偏好设置（System Preferences）</code>界面选中<code>共享（Sharing）</code>的同时，要按住<code>Option</code>键。见图：</p><h3 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h3><p><img src="/images/20160531/Snip20160531_2.png" alt="Snip20160531_2"></p><p>之后在<code>共享</code>界面中，我们会看到和之前不一样的地方，就是红框所标的地方，多了一个叫<code>创建 NAT64 网络</code> 的选框，选中它。</p><h3 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h3><p><img src="/images/20160531/Snip20160531_3.png" alt="Snip20160531_3"></p><p>接下来在<code>共享</code>窗口中，依次按图中所示的标号来，如图所示</p><h3 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h3><p><img src="/images/20160531/Snip20160531_4.png" alt="Snip20160531_4"></p><p>随后请点击<code>共享以下来源的连接</code>的下拉列表，选择我们想要共享出去的网络接口。我当前是想要共享的是<code>以太网</code>。</p><p><strong>PS：</strong>如果你的<code>Mac</code>是用有线拨号上网的话，请选择<code>PPOE</code>选项作为共享源。如果你的<code>Mac</code>是用有线上网（不用拨号的）的话，请选择<code>Thunderbolt 以太网有线网</code>选项作为共享源如果使用的是有线的<code>RJ-45</code>接头转<code>USB</code>输出的网络转换工具，请选<code>USB 10/100/1000 LAN</code>。</p><p><strong>标号1</strong></p><p><img src="/images/20160531/Snip20160531_5.png" alt="Snip20160531_5"></p><p><strong>标号2：</strong>用以下端口共享给电脑 选项此处选择<code>Wi-Fi</code></p><p><img src="/images/20160531/Snip20160531_6.png" alt="Snip20160531_6"></p><p><strong>标号3：</strong>点击<code>Wi-Fi选项...</code>选项，个性化自己的热点的设置</p><p><img src="/images/20160531/Snip20160531_7.png" alt="Snip20160531_7"></p><h3 id="步骤四："><a href="#步骤四：" class="headerlink" title="步骤四："></a>步骤四：</h3><p><img src="/images/20160531/Snip20160531_8.png" alt="Snip20160531_8"></p><h2 id="四、大功告成"><a href="#四、大功告成" class="headerlink" title="四、大功告成"></a>四、大功告成</h2><p>出现以下变化证明你已经成功产生了一个<code>IPv6</code>的热点</p><p><img src="/images/20160531/Snip20160531_9.png" alt="Snip20160531_9"></p><p><code>Wi-Fi</code>图标变样</p><p><img src="/images/20160531/Snip20160531_10.png" alt="Snip20160531_10"></p><p><strong>看手机的连接共享<code>Wi-Fi</code>的变化</strong><br><strong>普通热点共享</strong></p><p><img src="/images/20160531/Snip20160531_11.png" alt="Snip20160531_11"></p><p><strong><code>IPv6</code>热点共享</strong></p><p><img src="/images/20160531/Snip20160531_12.png" alt="Snip20160531_12"></p><p>对比2张图中<code>DNS</code>的地址看到区别了吧，一个<code>.</code>分割，一个<code>:</code>分割。</p><p>接下来就是测试你的<code>APP</code>是否可以在该WiFi下是否可以访问网络了</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;最近有很多人都在关注支持&lt;code&gt;IPv6&lt;/code&gt;的事情，果然是苹果打个哈欠，&lt;code&gt;iOS&lt;/code&gt;行业内就得起一次风暴呀。自从5月初&lt;code&gt;Apple&lt;/code&gt;明文规定所有开发者在6月1号以后提交新版本必须需要支持&lt;code&gt;IPv6-Only&lt;/code&gt;的网络。&lt;/p&gt;
&lt;h2 id=&quot;二、IPv6-Only支持是什么？&quot;&gt;&lt;a href=&quot;#二、IPv6-Only支持是什么？&quot; class=&quot;headerlink&quot; title=&quot;二、IPv6-Only支持是什么？&quot;&gt;&lt;/a&gt;二、&lt;code&gt;IPv6-Only&lt;/code&gt;支持是什么？&lt;/h2&gt;&lt;p&gt;&lt;code&gt;IPv6&lt;/code&gt;是对&lt;code&gt;IPv4&lt;/code&gt;地址空间的扩充，&lt;code&gt;IPv4&lt;/code&gt;和&lt;code&gt;IPv6&lt;/code&gt;的区别就是&lt;code&gt;IP&lt;/code&gt;地址前者是&lt;code&gt;.&lt;/code&gt;（&lt;code&gt;dot&lt;/code&gt;）分割，后者是以&lt;code&gt;:&lt;/code&gt;冒号）分割的（更多详细信息自行搜索）。
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="IPv6" scheme="http://blog.developerly.net/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 7.2 真机调试iOS 9.3的设备</title>
    <link href="http://blog.developerly.net/2016/04/13/Xcode%207.2%20%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95iOS.9.3%E7%9A%84%E8%AE%BE%E5%A4%87/"/>
    <id>http://blog.developerly.net/2016/04/13/Xcode 7.2 真机调试iOS.9.3的设备/</id>
    <published>2016-04-13T13:38:21.000Z</published>
    <updated>2017-12-25T15:15:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天回到家一不小心把测试机(没有设密码)升级到<code>9.3.1</code>了，立马悲剧了，<br>真机调试时报错：<code>Could not find Developer Disk Image</code>，<br>原因是：<code>Xcode7.2</code>中还没有支持<code>9.3</code>的<code>Disk Image</code>。</p><a id="more"></a><h2 id="iOS-9-3-gt-Could-not-find-Developer-Disk-Image真机调试错误解决办法"><a href="#iOS-9-3-gt-Could-not-find-Developer-Disk-Image真机调试错误解决办法" class="headerlink" title="iOS 9.3 -&gt; Could not find Developer Disk Image真机调试错误解决办法"></a><code>iOS 9.3</code> -&gt; <code>Could not find Developer Disk Image</code>真机调试错误解决办法</h2><ul><li><p>将<code>Xcode</code>更新到最新版本<code>7.3</code>，因为支持<code>iOS 9.3</code>的<code>Xcode</code>版本为 <code>7.3</code>（但是<code>Xcode 7.3</code>要求最小系统为<code>10.11</code>，所以这个对于系统还是<code>10.10</code>的没有用）。</p></li><li><p>下载该<code>Disk Image</code>，放到<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport</code><br>文件夹下，重启<code>Xcode</code>即可解决此类问题。</p></li></ul><h2 id="资源文件下载地址"><a href="#资源文件下载地址" class="headerlink" title="资源文件下载地址"></a>资源文件下载地址</h2><ul><li><p>对于<code>Xcode</code>老是在<code>App Store</code>升级失败，而且下载慢，我找到了这个－－&gt; 官方<code>Xcode.dmg</code>文件下载链接：<a href="http://stackoverflow.com/questions/10335747/how-to-download-xcode-4-5-6-7-and-get-the-dmg-file/10335943#10335943" target="_blank" rel="noopener">超级传送门</a> </p></li><li><p><code>Disk Image 9.3</code> 下载地址：<a href="http://pan.baidu.com/s/1o7RwhlC" target="_blank" rel="noopener">http://pan.baidu.com/s/1o7RwhlC</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天回到家一不小心把测试机(没有设密码)升级到&lt;code&gt;9.3.1&lt;/code&gt;了，立马悲剧了，&lt;br&gt;真机调试时报错：&lt;code&gt;Could not find Developer Disk Image&lt;/code&gt;，&lt;br&gt;原因是：&lt;code&gt;Xcode7.2&lt;/code&gt;中还没有支持&lt;code&gt;9.3&lt;/code&gt;的&lt;code&gt;Disk Image&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="真机调试" scheme="http://blog.developerly.net/tags/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/"/>
    
      <category term="Disk Image" scheme="http://blog.developerly.net/tags/Disk-Image/"/>
    
  </entry>
  
  <entry>
    <title>iOS App上传项目遇到的问题</title>
    <link href="http://blog.developerly.net/2016/03/16/iOS%20App%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.developerly.net/2016/03/16/iOS App上传项目遇到的问题/</id>
    <published>2016-03-16T13:45:32.000Z</published>
    <updated>2017-12-25T14:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-提示iTunes-Store-operation-filed（Cannot-verify-client）"><a href="#1-提示iTunes-Store-operation-filed（Cannot-verify-client）" class="headerlink" title="1. 提示iTunes Store operation filed（Cannot verify client）"></a>1. 提示<code>iTunes Store operation filed（Cannot verify client）</code></h2><p><img src="/images/20160316/Snip20160316_0.png" alt="Snip20160316_0.png"></p><p><strong>错误原因：</strong>没有验证到<code>Itunes Store</code>，网速过慢导致，或者网络堵塞<br><strong>解决办法：</strong>找个网络快的地方再试试吧！！</p><hr><a id="more"></a><h2 id="2-在上传项目的时候，UpLoad-App-Store后弹出iTunes-Store-operation-failed"><a href="#2-在上传项目的时候，UpLoad-App-Store后弹出iTunes-Store-operation-failed" class="headerlink" title="2. 在上传项目的时候，UpLoad App Store后弹出iTunes Store operation failed"></a>2. 在上传项目的时候，<code>UpLoad App Store</code>后弹出<code>iTunes Store operation failed</code></h2><p><img src="/images/20160316/Snip20160316_1.png" alt="Snip20160316_1"></p><p><strong>错误原因：</strong>你在<code>Itunes Connect</code>（<a href="https://itunesconnect.apple.com" target="_blank" rel="noopener">https://itunesconnect.apple.com</a>）网站里没有对应你<code>Xcode</code>项目设置的这个<code>Bundle Id</code>的应用<br><strong>解决办法：</strong>去<a href="https://itunesconnect.apple.com" target="_blank" rel="noopener">https://itunesconnect.apple.com</a>添加这个应用</p><hr><h2 id="3-这个问题比较麻烦，多半是证书，描述文件Bundle-ID不匹配原因！"><a href="#3-这个问题比较麻烦，多半是证书，描述文件Bundle-ID不匹配原因！" class="headerlink" title="3. 这个问题比较麻烦，多半是证书，描述文件Bundle ID不匹配原因！"></a>3. 这个问题比较麻烦，多半是证书，描述文件<code>Bundle ID</code>不匹配原因！</h2><p><img src="/images/20160316/Snip20160316_2.png" alt="Snip20160316_2"></p><p><strong>错误原因：</strong>证书和描述文件不匹配。也就是你选择描述文件（而描述文件绑定的证书不是你机器上的证书）<br><strong>解决办法：</strong>让证书自动去寻找描述文件。看下图</p><p><img src="/images/20160316/Snip20160316_3.png" alt="Snip20160316_3"></p><p><img src="/images/20160316/Snip20160316_4.png" alt="Snip20160316_4"></p><p>如果还不行，就确认下你的证书和描述文件 是否真正对应上了!</p><hr><h2 id="4-Itunes-Store-operation-failed"><a href="#4-Itunes-Store-operation-failed" class="headerlink" title="4. Itunes Store operation failed"></a>4. <code>Itunes Store operation failed</code></h2><p><img src="/images/20160316/Snip20160316_5.png" alt="Snip20160316_5"></p><p><strong>解决方法：</strong>重新启动<code>Xcode</code>完全退出。</p><hr><h2 id="5-Archive是灰色的，不能选择"><a href="#5-Archive是灰色的，不能选择" class="headerlink" title="5. Archive是灰色的，不能选择"></a>5. <code>Archive</code>是灰色的，不能选择</h2><p><img src="/images/20160316/Snip20160316_6.png" alt="Snip20160316_6"></p><hr><h2 id="6-错误：二进制文件无效（构建版本无效）的问题"><a href="#6-错误：二进制文件无效（构建版本无效）的问题" class="headerlink" title="6. 错误：二进制文件无效（构建版本无效）的问题"></a>6. 错误：二进制文件无效（构建版本无效）的问题</h2><p><img src="/images/20160316/Snip20160316_7.png" alt="Snip20160316_7"></p><p><strong>错误原因：</strong>可能是你工程里有问题。<br><strong>解决办法：</strong>看看你当初注册申请的<code>App ID</code>绑定的邮箱，因为你这个构建版本有问题的时候，苹果公司会给你发个邮件（里面会详细说明你的问题）不过<code>百分之50</code>都是百度地图的问题 需要在这里添加<code>-ObjC</code>要注意大小写</p><p><img src="/images/20160316/Snip20160316_8.png" alt="Snip20160316_8"></p><p><strong><em><code>-Objc</code>作用是：</em></strong>加了这个参数后，链接器就会把静态库中所有的<code>Objective-C</code>类和分类都加载到最后的可执行文件中。</p><hr><h2 id="7-用Xcode直接上传App-Store出现如下图错误：（之前是用Xcode6-4上传的，提交了n次都报这个错）"><a href="#7-用Xcode直接上传App-Store出现如下图错误：（之前是用Xcode6-4上传的，提交了n次都报这个错）" class="headerlink" title="7. 用Xcode直接上传App Store出现如下图错误：（之前是用Xcode6.4上传的，提交了n次都报这个错）"></a>7. 用<code>Xcode</code>直接上传<code>App Store</code>出现如下图错误：（之前是用<code>Xcode6.4</code>上传的，提交了<code>n</code>次都报这个错）</h2><p><img src="/images/20160316/Snip20160316_9.png" alt="Snip20160316_9"></p><p><strong>解决办法：</strong>用<code>Xcode7</code>上传就不会包这个错误了，所以大家遇到这个问题，直接用<code>Xcode7</code>以上的版本提交。</p><hr><h2 id="8-上传iTunes报下面错误"><a href="#8-上传iTunes报下面错误" class="headerlink" title="8. 上传iTunes报下面错误"></a>8. 上传<code>iTunes</code>报下面错误</h2><p><img src="/images/20160316/Snip20160316_10.png" alt="Snip20160316_10"></p><p><strong>解决办法：</strong></p><p><img src="/images/20160316/Snip20160316_11.png" alt="Snip20160316_11"></p><hr><h2 id="9-打包时遇见的错误–App配置为iOS路由App"><a href="#9-打包时遇见的错误–App配置为iOS路由App" class="headerlink" title="9. 打包时遇见的错误–App配置为iOS路由App"></a>9. 打包时遇见的错误–<code>App</code>配置为<code>iOS</code>路由<code>App</code></h2><p>要将<code>App</code>配置为<code>iOS</code>路由<code>App</code>，请在<code>iTunes Connect</code>的我的<code>App</code>中的<code>App</code>版本页面上传<code>App</code>地区范围文件 </p><p><strong>解决办法：</strong></p><p><img src="/images/20160316/Snip20160316_12.png" alt="Snip20160316_12"></p><p>把<code>Map</code>关掉!</p><hr><h2 id="10-iOS此证书的签发者无效"><a href="#10-iOS此证书的签发者无效" class="headerlink" title="10. iOS此证书的签发者无效"></a>10. <code>iOS</code>此证书的签发者无效</h2><p>上传<code>App</code>报错,如图: </p><p><img src="/images/20160316/Snip20160316_13.png" alt="Snip20160316_13"></p><p><strong>解决办法：</strong></p><ol><li>下载<br><a href="http://demo.netfoucs.com/qxuewei/article/details/50704824#" target="_blank" rel="noopener">https://developer.apple.com/certificationauthority/AppleWWDRCA.cer</a><br>的证书，然后双击安装。</li><li>在钥匙串里选择登录,然后点选证书，在这个界面，选择工具栏的<code>View</code> -&gt;显示过期证书(<code>Show Expired Certificates</code>)，这时候你会发现一个过期的(<code>Apple Worldwide Developer Relations Certification Authority</code>），删除它。</li><li>在系统(System)的那一栏也有这个过期的<code>WWDR Certificate</code>，一并删除它。</li><li>不出意外你的证书那里从<code>This certificate has an invalid issuer</code>（此证书的签发者无效）变成了<code>This certificate is valid</code>了。</li></ol><hr><h2 id="11-上传时遇到以下错误"><a href="#11-上传时遇到以下错误" class="headerlink" title="11. 上传时遇到以下错误"></a>11. 上传时遇到以下错误</h2><p><img src="/images/20160316/Snip20160316_14.png" alt="Snip20160316_14"></p><p><strong>解决方法：</strong></p><p>很简单<code>Xcode</code> -&gt; <code>Product</code> -&gt; <code>Clean</code>，然后重新打包！</p><hr><h2 id="12-将App上传到App-Store的时候通常会遇到这个问题"><a href="#12-将App上传到App-Store的时候通常会遇到这个问题" class="headerlink" title="12. 将App上传到App Store的时候通常会遇到这个问题"></a>12. 将<code>App</code>上传到<code>App Store</code>的时候通常会遇到这个问题</h2><p><img src="/images/20160316/Snip20160316_15.png" alt="Snip20160316_15"></p><p><strong>解决方法：</strong></p><p>很多人说苹果那边服务器问题，重复尝试几次，总会成功的！<br>不过我还是推荐用<code>Application Loader</code>上传，成功率就非常高。<br>如果<code>Application Loader</code>也不行，需要检查下自己的网络，有时候<code>VPN</code>也会提高速度（不行就等一段时间试试）。</p><p>其他<a href="http://blog.csdn.net/ws1352864983/article/details/52314776" target="_blank" rel="noopener"> iOS Xcode 打包IPA问题集锦  </a></p><p>###还有什么问题？欢迎大家补充…</p><ul><li>以上部分有转载网络其它文章，如果原作者有意见，可以联系我删除。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-提示iTunes-Store-operation-filed（Cannot-verify-client）&quot;&gt;&lt;a href=&quot;#1-提示iTunes-Store-operation-filed（Cannot-verify-client）&quot; class=&quot;headerlink&quot; title=&quot;1. 提示iTunes Store operation filed（Cannot verify client）&quot;&gt;&lt;/a&gt;1. 提示&lt;code&gt;iTunes Store operation filed（Cannot verify client）&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/20160316/Snip20160316_0.png&quot; alt=&quot;Snip20160316_0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误原因：&lt;/strong&gt;没有验证到&lt;code&gt;Itunes Store&lt;/code&gt;，网速过慢导致，或者网络堵塞&lt;br&gt;&lt;strong&gt;解决办法：&lt;/strong&gt;找个网络快的地方再试试吧！！&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="AppStore" scheme="http://blog.developerly.net/tags/AppStore/"/>
    
      <category term="App上传" scheme="http://blog.developerly.net/tags/App%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="UpLoad" scheme="http://blog.developerly.net/tags/UpLoad/"/>
    
  </entry>
  
  <entry>
    <title>iOS App上架流程（2016详细版）</title>
    <link href="http://blog.developerly.net/2016/03/15/iOS%20App%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B(2016%E8%AF%A6%E7%BB%86%E7%89%88)/"/>
    <id>http://blog.developerly.net/2016/03/15/iOS App上架流程(2016详细版)/</id>
    <published>2016-03-15T11:49:56.000Z</published>
    <updated>2017-12-25T14:34:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言："><a href="#一、前言：" class="headerlink" title="一、前言："></a>一、前言：</h2><p>作为一名<code>iOSer</code>，把开发出来的<code>App</code>上传到<code>App Store</code>是必要的。下面就来详细讲解一下具体流程步骤。</p><h2 id="二、准备："><a href="#二、准备：" class="headerlink" title="二、准备："></a>二、准备：</h2><ol><li>一个已付费的开发者账号（账号类型分为个人（<code>Individual</code>）、公司（<code>Company</code>）、企业（<code>Enterprise</code>）、高校（<code>University</code>）四种类型，每年资费分别为<code>$99</code>、<code>$99</code>、<code>$299</code>、<code>免费</code>。）。</li><li>一个已经开发完成的项目。</li></ol><a id="more"></a><h2 id="三、检查："><a href="#三、检查：" class="headerlink" title="三、检查："></a>三、检查：</h2><ol><li>你的<code>Xcode</code>必须是正式版的，<code>beta</code>版本的<code>Xcode</code>是不能上传项目的。</li><li>上传使用的<code>Mac</code>的<code>OS X</code>系统必须也是正式版的，<code>beta</code>版本也不行。</li><li>请确认你安装的<code>Xcode</code>是从<code>App Store</code>或者是开发者网站下载的，而不是从其它渠道获取的安装包安装的,因为非官方途径下载的<code>Xcode</code>可能带有<code>XcodeGhost</code>病毒。如何检查？</li></ol><p><img src="/images/20160315/Snip20160315_0.png" alt="检查方法"></p><h2 id="四、生成发布证书"><a href="#四、生成发布证书" class="headerlink" title="四、生成发布证书"></a>四、生成发布证书</h2><h3 id="1-打开苹果开发者中心：https-developer-apple-com"><a href="#1-打开苹果开发者中心：https-developer-apple-com" class="headerlink" title="1. 打开苹果开发者中心：https://developer.apple.com"></a>1. 打开苹果开发者中心：<a href="https://developer.apple.com" target="_blank" rel="noopener">https://developer.apple.com</a></h3><p>打开后点击：<code>Account</code></p><p><img src="/images/20160315/Snip20160315_1.png" alt="苹果开发者中心"></p><p>下面输入已付款过的<code>Apple</code>账号和密码登录（如果你的电脑已经保存了密码，会直接进入）</p><p><img src="/images/20160315/Snip20160315_2.png" alt="开发者登录账号"></p><h3 id="2-点击：Certificates-Identifiers-amp-Profiles-专门生成证书，绑定Bundle-Id，绑定device设备，生成描述文件的地方"><a href="#2-点击：Certificates-Identifiers-amp-Profiles-专门生成证书，绑定Bundle-Id，绑定device设备，生成描述文件的地方" class="headerlink" title="2. 点击：Certificates, Identifiers &amp; Profiles (专门生成证书，绑定Bundle Id，绑定device设备，生成描述文件的地方)"></a>2. 点击：<code>Certificates</code>, <code>Identifiers &amp; Profiles</code> (专门生成证书，绑定<code>Bundle Id</code>，绑定<code>device</code>设备，生成描述文件的地方)</h3><p><img src="/images/20160315/Snip20160315_3.png" alt="Member Center"></p><h3 id="3-点击Certificates生成证书"><a href="#3-点击Certificates生成证书" class="headerlink" title="3. 点击Certificates生成证书"></a>3. 点击<code>Certificates</code>生成证书</h3><ol><li>选择<code>iOS, tvOS, watchOS</code></li><li>选择<code>All</code></li><li>点击右上角新添加证书</li></ol><p><img src="/images/20160315/Snip20160315_4.png" alt="添加新证书1"></p><h3 id="4-由于是做App上传，选择生产证书（选择App-Store-and-Ad-Hoc）"><a href="#4-由于是做App上传，选择生产证书（选择App-Store-and-Ad-Hoc）" class="headerlink" title="4. 由于是做App上传，选择生产证书（选择App Store and Ad Hoc）"></a>4. 由于是做<code>App</code>上传，选择生产证书（选择<code>App Store and Ad Hoc</code>）</h3><p><img src="/images/20160315/Snip20160315_5.png" alt="选择App Store and Ad Hoc"></p><p><strong>注意：</strong> 一个开发者账号只能创建（1-2个开发（测试）证书，2-3个生产（发布）证书），如果你的<code>App Store Ad Hoc</code>前面的按钮不能选择，则代表你的这个账号无法再创建新的生产证书了。</p><p>解决方法：</p><ol><li>从共同使用这个账号的人电脑上生成.p12文件，导入自己的电脑。（尽量不要执行下面第2步）</li><li>如果你想生成的话，把现有的删除一个（建议删除时间比较靠前的）。注意：如果删除一个证书，那么正在使用这个证书的人将不能再使用了，除非重新生成，然后利用.p12重新导入自己的电脑里！</li></ol><p><strong><em>注意：</em></strong>如果你想删除证书，执行下面步骤，否则略过。</p><p><img src="/images/20160315/Snip20160315_6.png" alt="删除证书"></p><p>然后接上上图，生产证书部分继续</p><p><img src="/images/20160315/Snip20160315_7.png" alt="生成证书2"></p><p><img src="/images/20160315/Snip20160315_8.png" alt="生成证书3"></p><p><img src="/images/20160315/Snip20160315_9.png" alt="生成证书4"></p><h3 id="5-上传CSR文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）"><a href="#5-上传CSR文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）" class="headerlink" title="5. 上传CSR文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）"></a>5. 上传<code>CSR</code>文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）</h3><h4 id="1-在Launchpad的其他里面，点击钥匙串访问弹出如下界面"><a href="#1-在Launchpad的其他里面，点击钥匙串访问弹出如下界面" class="headerlink" title="1. 在Launchpad的其他里面，点击钥匙串访问弹出如下界面"></a>1. 在<code>Launchpad</code>的<strong>其他</strong>里面，点击<strong>钥匙串访问</strong>弹出如下界面</h4><p><img src="/images/20160315/Snip20160315_10.png" alt="其他"></p><p><img src="/images/20160315/Snip20160315_11.png" alt="钥匙串访问"></p><h4 id="2-工具栏选择钥匙串访问-gt-证书助理-gt-从证书颁发机构请求证书…"><a href="#2-工具栏选择钥匙串访问-gt-证书助理-gt-从证书颁发机构请求证书…" class="headerlink" title="2. 工具栏选择钥匙串访问-&gt;证书助理-&gt;从证书颁发机构请求证书…"></a>2. 工具栏选择<strong>钥匙串访问</strong>-&gt;<strong>证书助理</strong>-&gt;<strong>从证书颁发机构请求证书…</strong></h4><p><img src="/images/20160315/Snip20160315_12.png" alt="请求证书"></p><p><img src="/images/20160315/Snip20160315_13.png" alt="证书信息"></p><h4 id="3-将CSR文件保存到MAC磁盘的某个位置（这里我选择的是桌面，进行存储）"><a href="#3-将CSR文件保存到MAC磁盘的某个位置（这里我选择的是桌面，进行存储）" class="headerlink" title="3. 将CSR文件保存到MAC磁盘的某个位置（这里我选择的是桌面，进行存储）"></a>3. 将<code>CSR</code>文件保存到<code>MAC</code>磁盘的某个位置（这里我选择的是桌面，进行存储）</h4><p><img src="/images/20160315/Snip20160315_14.png" alt="存储证书"></p><p><img src="/images/20160315/Snip20160315_15.png" alt="点击完成"></p><p><img src="/images/20160315/Snip20160315_16.png" alt="CertificateSigningRequest.certSigningRequest 文件"></p><h3 id="6-然后回到浏览器，点击Choose-File"><a href="#6-然后回到浏览器，点击Choose-File" class="headerlink" title="6. 然后回到浏览器，点击Choose File..."></a>6. 然后回到浏览器，点击<code>Choose File...</code></h3><p><img src="/images/20160315/Snip20160315_17.png" alt="选择CSR文件"></p><h3 id="7-选择创建好的：CertificateSigningRequest-certSigningRequest文件，点击选取"><a href="#7-选择创建好的：CertificateSigningRequest-certSigningRequest文件，点击选取" class="headerlink" title="7. 选择创建好的：CertificateSigningRequest.certSigningRequest文件，点击选取"></a>7. 选择创建好的：<code>CertificateSigningRequest.certSigningRequest</code>文件，点击<strong>选取</strong></h3><p><img src="/images/20160315/Snip20160315_18.png" alt="选取CSR文件"></p><p>点击<code>Generate</code>上传证书</p><p><img src="/images/20160315/Snip20160315_19.png" alt="上传CSR证书"></p><h3 id="8-跳转到如下界面，点击-DownLoad-下载生成的证书（cer后缀的文件），然后点击Done，你创建的发布证书就会存储在帐号中。"><a href="#8-跳转到如下界面，点击-DownLoad-下载生成的证书（cer后缀的文件），然后点击Done，你创建的发布证书就会存储在帐号中。" class="headerlink" title="8. 跳转到如下界面，点击 DownLoad 下载生成的证书（cer后缀的文件），然后点击Done，你创建的发布证书就会存储在帐号中。"></a>8. 跳转到如下界面，点击 <strong>DownLoad</strong> 下载生成的证书（<code>cer</code>后缀的文件），然后点击<code>Done</code>，你创建的发布证书就会存储在帐号中。</h3><p><img src="/images/20160315/Snip20160315_20.png" alt="下载生成的证书"></p><p><img src="/images/20160315/Snip20160315_21.png" alt="cer后缀的文件"></p><p><strong>注意：</strong>这个证书只能下载一次。点击下载后，关闭页面后就不能再回到下载页面了。<br>如果不需要给别的电脑使用，则直接跳过下面<strong>附加项</strong>，跳转到<strong>第五步</strong>（绑定<code>Bundle Identifier</code>）</p><h3 id="附加项：生成p12文件在其他电脑上使用这个发布证书"><a href="#附加项：生成p12文件在其他电脑上使用这个发布证书" class="headerlink" title="附加项：生成p12文件在其他电脑上使用这个发布证书"></a>附加项：生成<code>p12</code>文件在其他电脑上使用这个发布证书</h3><h4 id="1-双击安装证书后，打开钥匙串访问，选择安装的证书右键单击"><a href="#1-双击安装证书后，打开钥匙串访问，选择安装的证书右键单击" class="headerlink" title="1. 双击安装证书后，打开钥匙串访问，选择安装的证书右键单击"></a>1. 双击安装证书后，打开钥匙串访问，选择安装的证书右键单击</h4><p><img src="/images/20160315/Snip20160315_22.png" alt="安装的发布证书"></p><p><strong>注意：</strong>如果没有<strong><em>导出</em></strong>，可以把这个证书删除，然后重新双击下载的证书文件安装。</p><h4 id="2-导出证书"><a href="#2-导出证书" class="headerlink" title="2. 导出证书"></a>2. 导出证书</h4><p><img src="/images/20160315/Snip20160315_23.png" alt="导出证书"></p><h4 id="3-存储证书"><a href="#3-存储证书" class="headerlink" title="3. 存储证书"></a>3. 存储证书</h4><p><img src="/images/20160315/Snip20160315_24.png" alt="存储导出的证书"></p><p><strong>注意：</strong>存储的文件格式一定要是<code>.p12</code></p><h4 id="4-设置密码"><a href="#4-设置密码" class="headerlink" title="4. 设置密码"></a>4. 设置密码</h4><p>可以为证书设置密码，也可以不设置密码；如果设置了密码，那么别人安装这个证书的时候就要输入密码，否则无法安装。这里就不设置密码了。</p><p><img src="/images/20160315/Snip20160315_25.png" alt="设置密码"></p><h4 id="5-保存导出的证书"><a href="#5-保存导出的证书" class="headerlink" title="5. 保存导出的证书"></a>5. 保存导出的证书</h4><p><img src="/images/20160315/Snip20160315_26.png" alt="p12发布证书"></p><p>如果需要在其它电脑上也能发布App,那么就必须要安装这个发布证书。</p><h2 id="五、创建App-IDs和绑定你的App的Bundle-Identifier"><a href="#五、创建App-IDs和绑定你的App的Bundle-Identifier" class="headerlink" title="五、创建App IDs和绑定你的App的Bundle Identifier"></a>五、创建<code>App IDs</code>和绑定你的<code>App</code>的<code>Bundle Identifier</code></h2><p>回到刚才的页面：<a href="https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action" target="_blank" rel="noopener">https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action</a></p><h3 id="1-点击App-IDs-进入如下界面，点击右上角的-号"><a href="#1-点击App-IDs-进入如下界面，点击右上角的-号" class="headerlink" title="1. 点击App IDs,进入如下界面，点击右上角的 + 号"></a>1. 点击<code>App IDs</code>,进入如下界面，点击右上角的 <strong>+</strong> 号</h3><p><img src="/images/20160315/Snip20160315_27.png" alt="点击App IDs"></p><h3 id="2-填写App-IDs和Bundle-Identifier"><a href="#2-填写App-IDs和Bundle-Identifier" class="headerlink" title="2. 填写App IDs和Bundle Identifier"></a>2. 填写<code>App IDs</code>和<code>Bundle Identifier</code></h3><p><img src="/images/20160315/Snip20160315_28.png" alt="填写App IDs和Bundle Identifier"></p><p><strong>注意：</strong></p><ol><li>上传<code>App</code>使用的<code>Bundle Identifier</code>(不要有<code>-</code>，都是英文<code>+</code>数字)必须是固定的，不能使用占位符。</li><li>如果你的<code>Bundle Identifier</code>已经在网站上绑定了，如果你又修改了你工程里面这个<code>Bundle Identifier</code>的话，需要重新进入到开发者账号里面绑定。</li></ol><p><img src="/images/20160315/Snip20160315_29.png" alt="修改工程的Bundle Identifier"></p><p>下面选择<code>App</code>中包含的服务，默认有两项，其余的根据自己项目的需求进行选择</p><p><img src="/images/20160315/Snip20160315_30.png" alt="App Services"></p><h3 id="3-点击Continue"><a href="#3-点击Continue" class="headerlink" title="3. 点击Continue"></a>3. 点击<code>Continue</code></h3><p><img src="/images/20160315/Snip20160315_31.png" alt="点击continue"></p><h3 id="4-点击Register"><a href="#4-点击Register" class="headerlink" title="4. 点击Register"></a>4. 点击<code>Register</code></h3><p><img src="/images/20160315/Snip20160315_32.png" alt="点击Register"></p><h3 id="5-点击Done"><a href="#5-点击Done" class="headerlink" title="5. 点击Done"></a>5. 点击<code>Done</code></h3><p><img src="/images/20160315/Snip20160315_33.png" alt="点击Done"></p><h2 id="六、生成描述文件（描述文件的作用就是把证书和Bundle-Identifier关联起来）"><a href="#六、生成描述文件（描述文件的作用就是把证书和Bundle-Identifier关联起来）" class="headerlink" title="六、生成描述文件（描述文件的作用就是把证书和Bundle Identifier关联起来）"></a>六、生成描述文件（描述文件的作用就是把证书和<code>Bundle Identifier</code>关联起来）</h2><h3 id="1-找到Provisioning-Profiles-，点击All，然后点击右上角-号"><a href="#1-找到Provisioning-Profiles-，点击All，然后点击右上角-号" class="headerlink" title="1. 找到Provisioning Profiles ，点击All，然后点击右上角 + 号"></a>1. 找到<code>Provisioning Profiles</code> ，点击<code>All</code>，然后点击右上角 <code>+</code> 号</h3><p><img src="/images/20160315/Snip20160315_34.png" alt="Provisioning Profiles"></p><h3 id="2-因为是发布，所以选择下面App-Store这个描述文件，点击Continue"><a href="#2-因为是发布，所以选择下面App-Store这个描述文件，点击Continue" class="headerlink" title="2. 因为是发布，所以选择下面App Store这个描述文件，点击Continue"></a>2. 因为是发布，所以选择下面<code>App Store</code>这个描述文件，点击<code>Continue</code></h3><p><img src="/images/20160315/Snip20160315_35.png" alt="选择App Store"></p><h3 id="3-在App-ID这个选项栏里面找到你刚刚创建的：App-IDs（Bundle-Identifier）类型的套装，点击Continue"><a href="#3-在App-ID这个选项栏里面找到你刚刚创建的：App-IDs（Bundle-Identifier）类型的套装，点击Continue" class="headerlink" title="3. 在App ID这个选项栏里面找到你刚刚创建的：App IDs（Bundle Identifier）类型的套装，点击Continue"></a>3. 在<code>App ID</code>这个选项栏里面找到你刚刚创建的：<code>App IDs</code>（<code>Bundle Identifier</code>）类型的套装，点击<code>Continue</code></h3><p><img src="/images/20160315/Snip20160315_36.png" alt="选择发布项目的Bundle Identifier"></p><h3 id="4-选择你刚创建的发布证书（或者生成p12文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击Continue"><a href="#4-选择你刚创建的发布证书（或者生成p12文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击Continue" class="headerlink" title="4. 选择你刚创建的发布证书（或者生成p12文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击Continue"></a>4. 选择你刚创建的发布证书（或者生成<code>p12</code>文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击<code>Continue</code></h3><p><img src="/images/20160315/Snip20160315_37.png" alt="选择创建的发布证书"></p><h3 id="5-在Profile-Name栏里输入一个名字（这个是Provisioning-Profiles文件的名字，可随便输入，在这里我用工程名字，便于分别），然后点击Generate"><a href="#5-在Profile-Name栏里输入一个名字（这个是Provisioning-Profiles文件的名字，可随便输入，在这里我用工程名字，便于分别），然后点击Generate" class="headerlink" title="5. 在Profile Name栏里输入一个名字（这个是Provisioning Profiles文件的名字，可随便输入，在这里我用工程名字，便于分别），然后点击Generate"></a>5. 在<code>Profile Name</code>栏里输入一个名字（这个是<code>Provisioning Profiles</code>文件的名字，可随便输入，在这里我用工程名字，便于分别），然后点击<code>Generate</code></h3><p><img src="/images/20160315/Snip20160315_38.png" alt="给描述文件起个名字"></p><h3 id="6-Download生成的Provisioning-Profiles文件，然后点击Done，双击安装（闪一下就完事了，没其它效果）"><a href="#6-Download生成的Provisioning-Profiles文件，然后点击Done，双击安装（闪一下就完事了，没其它效果）" class="headerlink" title="6. Download生成的Provisioning Profiles文件，然后点击Done，双击安装（闪一下就完事了，没其它效果）"></a>6. <code>Download</code>生成的<code>Provisioning Profiles</code>文件，然后点击<code>Done</code>，双击安装（闪一下就完事了，没其它效果）</h3><p><img src="/images/20160315/Snip20160315_39.png" alt="Download生成的PP文件"></p><p><img src="/images/20160315/Snip20160315_40.png" alt="生成的描述文件"></p><h2 id="六、在App-Store开辟空间"><a href="#六、在App-Store开辟空间" class="headerlink" title="六、在App Store开辟空间"></a>六、在<code>App Store</code>开辟空间</h2><h3 id="1-回到Member-Center，点击iTunes-Connect"><a href="#1-回到Member-Center，点击iTunes-Connect" class="headerlink" title="1. 回到Member Center，点击iTunes Connect"></a>1. 回到<code>Member Center</code>，点击<code>iTunes Connect</code></h3><p><img src="/images/20160315/Snip20160315_41.png" alt="点击iTunes Connect"></p><h3 id="2-登录开发者账号（还是之前已付费的账号）"><a href="#2-登录开发者账号（还是之前已付费的账号）" class="headerlink" title="2. 登录开发者账号（还是之前已付费的账号）"></a>2. 登录开发者账号（还是之前已付费的账号）</h3><p><img src="/images/20160315/Snip20160315_42.png" alt="Snip20160315_68.png"></p><h3 id="3-登录成功后，点击我的App"><a href="#3-登录成功后，点击我的App" class="headerlink" title="3. 登录成功后，点击我的App"></a>3. 登录成功后，点击<code>我的App</code></h3><p><img src="/images/20160315/Snip20160315_43.png" alt="点击我的App"></p><h3 id="4-点击左上角那个＋号，点击新建-注意：我们是iOS-App开发，不要选Mac-App啦）"><a href="#4-点击左上角那个＋号，点击新建-注意：我们是iOS-App开发，不要选Mac-App啦）" class="headerlink" title="4. 点击左上角那个＋号，点击新建(注意：我们是iOS App开发，不要选Mac App啦）"></a>4. 点击左上角那个<code>＋</code>号，点击新建(注意：我们是<code>iOS App</code>开发，不要选<code>Mac App</code>啦）</h3><p><img src="/images/20160315/Snip20160315_44.png" alt="新建 App"></p><h3 id="5-依次按提示填入对应信息（SKU是公司用于做统计数据之类的id，根据公司需求填写），然后点击创建"><a href="#5-依次按提示填入对应信息（SKU是公司用于做统计数据之类的id，根据公司需求填写），然后点击创建" class="headerlink" title="5. 依次按提示填入对应信息（SKU是公司用于做统计数据之类的id，根据公司需求填写），然后点击创建"></a>5. 依次按提示填入对应信息（<code>SKU</code>是公司用于做统计数据之类的<code>id</code>，根据公司需求填写），然后点击创建</h3><p><img src="/images/20160315/Snip20160315_45.png" alt="填写App信息"></p><p><strong>注意：</strong>如果都填好以后，可能会告诉你，你的<code>App</code>名称已经被占用，那么不好意思，你只能改名了！（而且建议大家起名不要往比较出名的<code>App</code>上靠，否则审核可能会被拒绝）</p><h3 id="6-填写App其它信息"><a href="#6-填写App其它信息" class="headerlink" title="6. 填写App其它信息"></a>6. 填写<code>App</code>其它信息</h3><p><img src="/images/20160315/Snip20160315_46.png" alt=" App信息"></p><h3 id="7-填写价格和销售范围（由于我的开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费）"><a href="#7-填写价格和销售范围（由于我的开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费）" class="headerlink" title="7. 填写价格和销售范围（由于我的开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费）"></a>7. 填写价格和销售范围（由于我的开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费）</h3><p><img src="/images/20160315/Snip20160315_47.png" alt="填写价格和销售范围"></p><h3 id="8-依次把不同尺寸的App截图拉入到对应的里面"><a href="#8-依次把不同尺寸的App截图拉入到对应的里面" class="headerlink" title="8. 依次把不同尺寸的App截图拉入到对应的里面"></a>8. 依次把不同尺寸的<code>App</code>截图拉入到对应的里面</h3><p>需要填写不同尺寸的手机屏幕截图（也就是拿不同尺寸的模拟器运行后，挑出至少3页最多5页进行截图然后拖到响应的区里）（在模拟器<code>Command + S</code>就可以保存屏幕截图到桌面了）（注意：如果提示拖进去的图片尺寸不对，则把模拟器弄成<code>100%</code>然后再<code>Command + S</code>    ) 尺寸参照表在下面</p><p><img src="/images/20160315/Snip20160315_48.png" alt="设置不同尺寸的App截图"></p><p>尺寸参照图：</p><p><img src="/images/20160315/Snip20160315_49.png" alt="尺寸参照图"></p><h3 id="9-填写App简介"><a href="#9-填写App简介" class="headerlink" title="9. 填写App简介"></a>9. 填写<code>App</code>简介</h3><p><img src="/images/20160315/Snip20160315_50.png" alt="填写App简介"></p><h3 id="10-按提示依次输入"><a href="#10-按提示依次输入" class="headerlink" title="10. 按提示依次输入"></a>10. 按提示依次输入</h3><p><img src="/images/20160315/Snip20160315_51.png" alt="按提示依次输入"></p><p><strong>错误提示：</strong>如果上传<code>App</code>图标失败，提示<code>Alpha</code>错误的话，看下面。</p><p>打开你的图标图片，勾掉这个</p><p><img src="/images/20160315/Snip20160315_52.png" alt="勾掉这个"></p><h3 id="11-点击分级后面的编辑，如实填写后，点击完成"><a href="#11-点击分级后面的编辑，如实填写后，点击完成" class="headerlink" title="11. 点击分级后面的编辑，如实填写后，点击完成"></a>11. 点击分级后面的编辑，如实填写后，点击完成</h3><p><img src="/images/20160315/Snip20160315_53.png" alt="分级信息"></p><h3 id="12-填写审核信息"><a href="#12-填写审核信息" class="headerlink" title="12. 填写审核信息"></a>12. 填写审核信息</h3><p><img src="/images/20160315/Snip20160315_54.png" alt="填写审核信息"></p><p>版本发布就是：（然后最下面选择自动发布的话就是如果审核通过，就自动上传到<code>App Store</code>供人下载）</p><h3 id="13-此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入Xcode中把项目打包发送到过来。"><a href="#13-此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入Xcode中把项目打包发送到过来。" class="headerlink" title="13. 此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入Xcode中把项目打包发送到过来。"></a>13. 此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入<code>Xcode</code>中把项目打包发送到过来。</h3><p><strong>注意：</strong>填写完一定要点击右上角的保存。</p><h2 id="七、在Xcode中打包工程"><a href="#七、在Xcode中打包工程" class="headerlink" title="七、在Xcode中打包工程"></a>七、在<code>Xcode</code>中打包工程</h2><p><strong>找到你刚刚下载的发布证书（后缀为<code>.cer</code>）或者<code>p12</code>文件，和PP文件，双击，看起来没反应，但是他们已经加入到你的钥匙串中。</strong></p><h3 id="1-在Xcode中选择iOS-Device-这里不能选择模拟器-，按照下图提示操作"><a href="#1-在Xcode中选择iOS-Device-这里不能选择模拟器-，按照下图提示操作" class="headerlink" title="1. 在Xcode中选择iOS Device(这里不能选择模拟器)，按照下图提示操作"></a>1. 在<code>Xcode</code>中选择<code>iOS Device</code>(这里不能选择模拟器)，按照下图提示操作</h3><p><img src="/images/20160315/Snip20160315_55.png" alt="选择iOS Device"></p><h3 id="2-如果你的应用不支持横屏，把这两个勾去掉"><a href="#2-如果你的应用不支持横屏，把这两个勾去掉" class="headerlink" title="2. 如果你的应用不支持横屏，把这两个勾去掉"></a>2. 如果你的应用不支持横屏，把这两个勾去掉</h3><p><img src="/images/20160315/Snip20160315_56.png" alt="如果你的应用不支持横屏，把这两个勾去掉"></p><h3 id="3-查看版本号和构建版本号"><a href="#3-查看版本号和构建版本号" class="headerlink" title="3. 查看版本号和构建版本号"></a>3. 查看版本号和构建版本号</h3><p><img src="/images/20160315/Snip20160315_57.png" alt="查看版本号和构建版本号"></p><h3 id="4-配置发布证书-ps-截图时选择的证书是错误的，大家注意一下，要选择发布证书"><a href="#4-配置发布证书-ps-截图时选择的证书是错误的，大家注意一下，要选择发布证书" class="headerlink" title="4. 配置发布证书(ps:截图时选择的证书是错误的，大家注意一下，要选择发布证书)"></a>4. 配置发布证书(<strong>ps:</strong>截图时选择的证书是错误的，大家注意一下，要选择发布证书)</h3><p><img src="/images/20160315/Snip20160315_58.png" alt="配置发布证书"></p><p><strong>注意：</strong>如果这里没有黄色叹号，代表你的配置没问题，如果有，那就是证书和描述文件不匹配，或者描述文件里刚才选的<code>Bundle</code>和现在的工程的<code>Bundle Identifier</code>不一致，去  <a href="https://develop.apple.com" target="_blank" rel="noopener">https://develop.apple.com</a>  上找到你的描述文件在确认下绑定的<code>bundle Identifier</code>和你工程是不是一样的？</p><p><img src="/images/20160315/Snip20160315_59.png" alt="检查"></p><h3 id="5-将断点、全局断点，僵尸模式等都要去掉。"><a href="#5-将断点、全局断点，僵尸模式等都要去掉。" class="headerlink" title="5. 将断点、全局断点，僵尸模式等都要去掉。"></a>5. 将<strong>断点</strong>、<strong>全局断点</strong>，<strong>僵尸模式</strong>等都要去掉。</h3><p><img src="/images/20160315/Snip20160315_60.png" alt="去掉断点、全局断点"></p><p><img src="/images/20160315/Snip20160315_61.png" alt="Snip20160315_60.png"></p><p><img src="/images/20160315/Snip20160315_62.png" alt="Snip20160315_61.png"></p><p><img src="/images/20160315/Snip20160315_63.png" alt="去掉僵尸模式"></p><h3 id="6-设置Release模式（Debug是测试的，Release是发布用的）"><a href="#6-设置Release模式（Debug是测试的，Release是发布用的）" class="headerlink" title="6. 设置Release模式（Debug是测试的，Release是发布用的）"></a>6. 设置<code>Release</code>模式（<code>Debug</code>是测试的，<code>Release</code>是发布用的）</h3><p><img src="/images/20160315/Snip20160315_64.png" alt="Snip20160315_63.png"></p><p><img src="/images/20160315/Snip20160315_65.png" alt="Snip20160315_64.png"></p><p><img src="/images/20160315/Snip20160315_66.png" alt="Snip20160315_65.png"></p><p><img src="/images/20160315/Snip20160315_67.png" alt="Snip20160315_66.png"></p><h3 id="7-选择Xcode下Product下Archive（专门用于传项目，或者打包项目）"><a href="#7-选择Xcode下Product下Archive（专门用于传项目，或者打包项目）" class="headerlink" title="7. 选择Xcode下Product下Archive（专门用于传项目，或者打包项目）"></a>7. 选择<code>Xcode</code>下<code>Product</code>下<code>Archive</code>（专门用于传项目，或者打包项目）</h3><p><img src="/images/20160315/Snip20160315_68.png" alt="选择Archive"></p><p><img src="/images/20160315/Snip20160315_69.png" alt="Snip20160315_68.png"></p><p><img src="/images/20160315/Snip20160315_70.png" alt="Snip20160315_69.png"></p><h3 id="8-出现下图说明你没有添加开发者账号，点击右下脚Add-按钮就可以添加"><a href="#8-出现下图说明你没有添加开发者账号，点击右下脚Add-按钮就可以添加" class="headerlink" title="8. 出现下图说明你没有添加开发者账号，点击右下脚Add...按钮就可以添加"></a>8. 出现下图说明你没有添加开发者账号，点击右下脚<code>Add...</code>按钮就可以添加</h3><p><img src="/images/20160315/Snip20160315_71.png" alt="没有添加开发者账号"></p><h3 id="9-输入付费的开发者账号"><a href="#9-输入付费的开发者账号" class="headerlink" title="9. 输入付费的开发者账号"></a>9. 输入付费的开发者账号</h3><p><img src="/images/20160315/Snip20160315_72.png" alt="输入开发者账号"></p><p>可能会弹出下面这个界面，如果不弹出，按<code>Command</code>加。</p><p><img src="/images/20160315/Snip20160315_73.png" alt="Snip20160315_72.png"></p><h3 id="10-然后回到Archive-选择已付费的账号-，然后点击Choose"><a href="#10-然后回到Archive-选择已付费的账号-，然后点击Choose" class="headerlink" title="10. 然后回到Archive(选择已付费的账号)，然后点击Choose"></a>10. 然后回到<code>Archive</code>(选择已付费的账号)，然后点击<code>Choose</code></h3><p><img src="/images/20160315/Snip20160315_74.png" alt="选择已付费的账号"></p><p>然后等待</p><p><img src="/images/20160315/Snip20160315_75.png" alt="等待"></p><h3 id="11-选择Upload提交"><a href="#11-选择Upload提交" class="headerlink" title="11. 选择Upload提交"></a>11. 选择<code>Upload</code>提交</h3><p><img src="/images/20160315/Snip20160315_76.png" alt="Upload提交"></p><h3 id="12-如下就代表上传成功，如果出错，请参照iOS-App上传项目遇到的问题"><a href="#12-如下就代表上传成功，如果出错，请参照iOS-App上传项目遇到的问题" class="headerlink" title="12. 如下就代表上传成功，如果出错，请参照iOS App上传项目遇到的问题"></a>12. 如下就代表上传成功，如果出错，请参照<a href="http://blog.developerly.net/2016/03/16/iOS%20App%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">iOS App上传项目遇到的问题</a></h3><p><img src="/images/20160315/Snip20160315_77.png" alt="上传成功"></p><h3 id="13-返回Itunes-Connect网站上你自己的App信息中查看一下"><a href="#13-返回Itunes-Connect网站上你自己的App信息中查看一下" class="headerlink" title="13. 返回Itunes Connect网站上你自己的App信息中查看一下"></a>13. 返回<code>Itunes Connect</code>网站上你自己的<code>App</code>信息中查看一下</h3><p><img src="/images/20160315/Snip20160315_78.png" alt="在App信息中查看"></p><h3 id="14-在这个构建版本这里就可以添加代码"><a href="#14-在这个构建版本这里就可以添加代码" class="headerlink" title="14. 在这个构建版本这里就可以添加代码"></a>14. 在这个构建版本这里就可以添加代码</h3><p><img src="/images/20160315/Snip20160315_79.png" alt="添加代码"></p><p>点击<code>＋</code>号之后选择代码版本</p><p><img src="/images/20160315/Snip20160315_80.png" alt="添加构建版本"></p><h3 id="15-提交以供审核"><a href="#15-提交以供审核" class="headerlink" title="15. 提交以供审核"></a>15. 提交以供审核</h3><p><img src="/images/20160315/Snip20160315_81.png" alt="提交以供审核"></p><h3 id="16-App已经从准备提交，变成正在等待审核状态"><a href="#16-App已经从准备提交，变成正在等待审核状态" class="headerlink" title="16. App已经从准备提交，变成正在等待审核状态"></a>16. <code>App</code>已经从准备提交，变成正在等待审核状态</h3><p><img src="/images/20160315/Snip20160315_82.png" alt="正在等待审核状态"></p><h3 id="17-等待苹果的审核…"><a href="#17-等待苹果的审核…" class="headerlink" title="17. 等待苹果的审核…"></a>17. 等待苹果的审核…</h3><h2 id="八、补充"><a href="#八、补充" class="headerlink" title="八、补充"></a>八、补充</h2><h3 id="构建版本的方法有两种，一种是使用Xcode-上面已经介绍了-，另一种就是使用一个叫Application-Loader这个软件："><a href="#构建版本的方法有两种，一种是使用Xcode-上面已经介绍了-，另一种就是使用一个叫Application-Loader这个软件：" class="headerlink" title="构建版本的方法有两种，一种是使用Xcode(上面已经介绍了)，另一种就是使用一个叫Application Loader这个软件："></a>构建版本的方法有两种，一种是使用<code>Xcode</code>(上面已经介绍了)，另一种就是使用一个叫<code>Application Loader</code>这个软件：</h3><p><img src="/images/20160315/Snip20160315_83.png" alt="Application Loader"></p><ul><li><p>使用Xcode构建版本：<br>上面已经介绍（已经<code>Archive</code>的话，可以在<code>Xcode: Window -&gt; Organizer</code>进入）<br><img src="/images/20160315/Snip20160315_84.png" alt="Upload to App Store..."></p></li><li><p>使用<code>Application Loader</code>构建版本：</p><ul><li>如上图，点击<code>Export...</code>，导出一个<code>ipa</code>文件（<strong>ps:</strong>为了保险起见、让苹果审核顺利一点，这里可以先点击<code>Validate...</code>来验证一下，这里就懒得验证了）</li><li><p><code>Application Loader</code>下载<code>Xcode</code>的时候就已经下载了（没有的请自行下载），<code>Xcode</code>右键弹出下面界面</p><p><img src="/images/20160315/Snip20160315_85.png" alt="Open Developer Tool"></p><p>打开Application Loader（如果没有登录，会提示你登录你的开发者账号）</p><p><img src="/images/20160315/Snip20160315_86.png" alt="Application Loader"></p><p>选取你导出的<code>ipa</code>文件（或者双击<code>交付您的应用程序</code>选取<code>ipa</code>文件），之后按提示操作就行，上传完毕没有报错的话，过几分钟左右就可以在<code>iTunes Connect</code>里面就可以看到你上传的这个版本了。</p><p><img src="/images/20160315/Snip20160315_87.png" alt="构建版本"></p></li></ul></li></ul><p>补充就这些吧，后面遇到再补充吧！个人建议构建版本使用<code>Application Loader</code>上传，成功率更高！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言：&quot;&gt;&lt;a href=&quot;#一、前言：&quot; class=&quot;headerlink&quot; title=&quot;一、前言：&quot;&gt;&lt;/a&gt;一、前言：&lt;/h2&gt;&lt;p&gt;作为一名&lt;code&gt;iOSer&lt;/code&gt;，把开发出来的&lt;code&gt;App&lt;/code&gt;上传到&lt;code&gt;App Store&lt;/code&gt;是必要的。下面就来详细讲解一下具体流程步骤。&lt;/p&gt;
&lt;h2 id=&quot;二、准备：&quot;&gt;&lt;a href=&quot;#二、准备：&quot; class=&quot;headerlink&quot; title=&quot;二、准备：&quot;&gt;&lt;/a&gt;二、准备：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;一个已付费的开发者账号（账号类型分为个人（&lt;code&gt;Individual&lt;/code&gt;）、公司（&lt;code&gt;Company&lt;/code&gt;）、企业（&lt;code&gt;Enterprise&lt;/code&gt;）、高校（&lt;code&gt;University&lt;/code&gt;）四种类型，每年资费分别为&lt;code&gt;$99&lt;/code&gt;、&lt;code&gt;$99&lt;/code&gt;、&lt;code&gt;$299&lt;/code&gt;、&lt;code&gt;免费&lt;/code&gt;。）。&lt;/li&gt;
&lt;li&gt;一个已经开发完成的项目。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="AppStore" scheme="http://blog.developerly.net/tags/AppStore/"/>
    
      <category term="App上架" scheme="http://blog.developerly.net/tags/App%E4%B8%8A%E6%9E%B6/"/>
    
      <category term="证书" scheme="http://blog.developerly.net/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题总结整理（附答案-持续更新）</title>
    <link href="http://blog.developerly.net/2016/03/13/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86%EF%BC%88%E9%99%84%E7%AD%94%E6%A1%88-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://blog.developerly.net/2016/03/13/iOS面试题总结整理（附答案-持续更新）/</id>
    <published>2016-03-13T13:48:05.000Z</published>
    <updated>2017-12-19T05:43:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-多线程的实现方式；"><a href="#1-多线程的实现方式；" class="headerlink" title="1. 多线程的实现方式；"></a>1. 多线程的实现方式；</h2><p><img src="/images/20160313/Snip20160313_1.png" alt="iOS中实现多线程的方案有4种"><br><a id="more"></a></p><h2 id="2-延迟执行的几种方式；"><a href="#2-延迟执行的几种方式；" class="headerlink" title="2. 延迟执行的几种方式；"></a>2. 延迟执行的几种方式；</h2><ul><li>延迟1秒执行代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)delayMethod&#123;</span><br><span class="line">NSLog(@&quot;delayMethodEnd&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>performSelector方法:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 此方式要求必须在主线程中执行，否则无效。</span><br><span class="line">// 是一种非阻塞的执行方式，暂时未找到取消执行的方法。</span><br><span class="line">[self performSelector:@selector(delayMethod) withObject:nil afterDelay:1.0f];</span><br></pre></td></tr></table></figure><ul><li>定时器：NSTimer;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 此方式要求必须在主线程中执行，否则无效。</span><br><span class="line">// 是一种非阻塞的执行方式，可以通过`NSTimer`类的`- (void)invalidate;`取消执行。</span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(delayMethod) userInfo:nil repeats:NO];</span><br></pre></td></tr></table></figure><ul><li>sleep方式；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 此方式在主线程和子线程中均执行。</span><br><span class="line">// 是一种阻塞的执行方式，`建议放到子线程中，以避免卡住界面`，没有找到取消执行的方法。</span><br><span class="line">[NSThread sleepForTimeInterval:1.0f]; [self delayMethod];</span><br></pre></td></tr></table></figure><ul><li>GCD方式<br></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 此方式可以在参数中选择执行的线程。</span><br><span class="line">// 是一种非阻塞的执行方式，</span><br><span class="line">// 没有找到取消执行的方式。</span><br><span class="line">__weak id safeSelf = self;  </span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">[safeSelf delayMethod];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-App崩溃的情况有多少种；"><a href="#3-App崩溃的情况有多少种；" class="headerlink" title="3. App崩溃的情况有多少种；"></a>3. App崩溃的情况有多少种；</h2><pre><code>1. 违反操作系统规则：比如启动恢复挂起退出时`watchdog`超时，用户强制退出或者低内存终止。2. 应用程序异常退出。</code></pre><h2 id="4-你使用过Objective-C的运行时编程（Runtime-Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"><a href="#4-你使用过Objective-C的运行时编程（Runtime-Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？" class="headerlink" title="4. 你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"></a>4. 你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？</h2><p>参考答案：</p><p><code>Objecitve-C</code>的重要特性是<code>Runtime</code>（运行时）,在<code>#import &lt;objc/runtime.h&gt;</code> 下能看到相关的方法，用过<code>objc_getClass()</code>和<code>class_copyMethodList()</code>获取过<code>私有API</code>; </p><p> 使用Objecitve-C<br> <code>Method method1 = class_getInstanceMethod(cls, sel1);</code><br> <code>Method method2 = class_getInstanceMethod(cls,  sel2);</code><br> <code>method_exchangeImplementations(method1, method2);</code> </p><p> 代码交换两个方法，在写<code>unit test</code>时使用到。</p><h2 id="5-对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？"><a href="#5-对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？" class="headerlink" title="5. 对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？"></a>5. 对于<code>Objective-C</code>，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？</h2><p>参考答案：</p><p>最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲突，可以使用长命名法或特殊前缀解决，如果是引入的第三方库之间的命名冲突，可以使用<code>link</code>命令及<code>flag</code>解决冲突。</p><h2 id="6-iOS中的几种传值问题？"><a href="#6-iOS中的几种传值问题？" class="headerlink" title="6. iOS中的几种传值问题？"></a>6. iOS中的几种传值问题？</h2><ul><li>顺传一般是直接传值</li><li><p>代理传值</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A&lt;B-Delegate&gt; // A实现B协议</span><br><span class="line">B // 声明协议和方法 声明代理属性</span><br><span class="line">Delegate-&gt;(methodFromB:(B)b value:(obj)obj)// B声明协议方法</span><br><span class="line">property-weak-deleagte</span><br><span class="line"></span><br><span class="line">// 在A中</span><br><span class="line">B.delegate = A;</span><br><span class="line"></span><br><span class="line">// 当B中发生传值时调用</span><br><span class="line">B</span><br><span class="line">[self.delegate methodFromB:self value:obj]</span><br><span class="line"></span><br><span class="line">// 因为 self.delegate = A</span><br><span class="line">// A中执行定义的协议方法接收到值</span><br><span class="line">-methodFromB:(B)b value:(obj)obj</span><br></pre></td></tr></table></figure></li><li><p>Block传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">// A中实现B的block的代码块</span><br><span class="line">B.block = ^(obj)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B // 声明代码块</span><br><span class="line">typedef BBlock</span><br><span class="line">property-block</span><br><span class="line"></span><br><span class="line">// 当B中调用</span><br><span class="line">self.block(obj);</span><br><span class="line">就会调用A中以实现的代码块实现传值</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通知传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A中接收通知</span><br><span class="line">NotificationCenter.addobserve(A).name(&quot;NAME&quot;).selector(noti:)</span><br><span class="line">-noti:(noti)noti&#123;</span><br><span class="line">  noti.obj// 接收到值</span><br><span class="line">&#125;</span><br><span class="line">B中发送通知</span><br><span class="line">NotificationCenter.postName(&quot;NAME&quot;).obj(obj)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>单例传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 用单例中的值更新A的值</span><br><span class="line">A.property = global.singleton.property;</span><br><span class="line">// B中值改变 把值赋给单例</span><br><span class="line">global.singleton.property = B.property;</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-什么是-ARC-ARC-是为了解决什么问题而诞生的"><a href="#7-什么是-ARC-ARC-是为了解决什么问题而诞生的" class="headerlink" title="7. 什么是 ARC? (ARC 是为了解决什么问题而诞生的?)"></a>7. 什么是 ARC? (ARC 是为了解决什么问题而诞生的?)</h2><p> <code>ARC</code> 是 <code>Automatic Reference Counting</code> 的缩写, 即自动引用计数. 这是苹果在 <code>iOS5</code> 中引入的内存管理机制. <code>Objective-C</code> 和 <code>Swift</code> 使用 <code>ARC</code> 追踪和管理应用的内存使用. 这一机制使得开发者无需键入 <code>retain</code>和 <code>release</code><br>, 这不仅能够降低程序崩溃和内存泄露的风险, 而且可以减少开发者的工作量, 能够大幅度提升程序的<strong>流畅性</strong>和<strong>可预测性</strong>. 但是 <code>ARC</code> 不适用于 <code>Core Foundation</code> 框架中, 仍然需要手动管理内存.</p><h2 id="8-以下-keywords-有什么区别-assign-vs-weak-block-vs-weak"><a href="#8-以下-keywords-有什么区别-assign-vs-weak-block-vs-weak" class="headerlink" title="8. 以下 keywords 有什么区别: assign vs weak ,__block vs __weak"></a>8. 以下 keywords 有什么区别: <code>assign</code> vs <code>weak</code> ,<code>__block</code> vs <code>__weak</code></h2><p><code>assign</code> 和 <code>weak</code>是用于在声明属性时, 为属性指定内存管理的语义.</p><ul><li>assign 用于简单的赋值, 不改变属性的引用计数, 用于 Objective-C 中的 <code>NSInteger</code> , <code>CGFloat</code> 以及 C 语言中 <code>int</code> , <code>float</code> , <code>double</code> 等数据类型.</li><li><code>weak</code> 用于对象类型, 由于 <code>weak</code> 同样不改变对象的引用计数且不持有对象实例, 当该对象废弃时, 该弱引用自动失效并且被赋值为 nil , 所以它可以用于避免两个强引用产生的<strong>循环引用</strong>导致内存无法释放的问题.</li></ul><p><code>__block</code> 和 <code>__weak</code> 之间的却是确实极大的, 不过它们都用于修饰变量.</p><ul><li>前者用于指明当前声明的变量在被 block 捕获之后, 可以在 block 中改变变量的值. 因为在 block 声明的同时会截获该 block 所使用的全部自动变量的值, 而这些值只在 block 中<strong>只具有”使用权”而不具有”修改权”</strong>. 而 __block 说明符就为 block 提供了变量的修改权. </li><li>后者是<strong>所有权修饰符</strong>, 什么是所有权修饰符? 这里涉及到另一个问题, 因为在 ARC 有效时, id 类型和对象类型同 C 语言中的其他类型不同, 必须附加所有权修饰符. 所有权修饰符一种有 4 种:</li><li>__strong</li><li>__weak</li><li>__unsafe_unretained</li><li>__autorelease</li><li><code>__weak</code> 与 <code>weak</code> 的区别只在于, 前者用于变量的声明, 而后者用于属性的声明.</li></ul><h2 id="9-block-在-ARC-和非-ARC-下含义一样吗？"><a href="#9-block-在-ARC-和非-ARC-下含义一样吗？" class="headerlink" title="9. __block 在 ARC 和非 ARC 下含义一样吗？"></a>9. <code>__block</code> 在 ARC 和非 ARC 下含义一样吗？</h2><p><code>__block</code> <strong>在 ARC 下捕获的变量会被 block retain</strong>, 这样可能导致循环引用, 所以必须要使用弱引用才能解决该问题.<br>而在非 ARC 下, 可以直接使用 <code>__block</code> 说明符修饰变量, 因为在非 ARC 下, <code>block</code> 不会 <code>retain</code> 捕获的变量.</p><h2 id="10-viewWillLayoutSubviews-的作用是什么"><a href="#10-viewWillLayoutSubviews-的作用是什么" class="headerlink" title="10. viewWillLayoutSubviews 的作用是什么?"></a>10. <code>viewWillLayoutSubviews</code> 的作用是什么?</h2><p> <code>viewWillLayoutSubviews</code> 方法会在视图的 <code>bounds</code> 改变时, 视图会调整子视图的位置, 我们可以在视图控制器中覆写这个方法在视图放置子视图前做出改变, 当屏幕的方向改变时, 这个方法会被调用.</p><h2 id="11-SDWebImage-里面给-UIImageView-加载图片的逻辑是什么样的"><a href="#11-SDWebImage-里面给-UIImageView-加载图片的逻辑是什么样的" class="headerlink" title="11. SDWebImage 里面给 UIImageView 加载图片的逻辑是什么样的?"></a>11. <code>SDWebImage</code> 里面给 <code>UIImageView</code> 加载图片的逻辑是什么样的?</h2><p>我曾经阅读过 <code>SDWebImage</code> 的源代码, 就在这里对如何给 <code>UIImageView</code> 加载图片做一个总结吧, <code>SDWebImage</code> 中为 <code>UIView</code> 提供了一个分类叫做 <code>WebCache</code>, 这个分类中有一个最常用的接口, <code>sd_setImageWithURL:placeholderImage:</code> , 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 <code>option</code> <code>progressBlock</code> <code>completionBlock</code>的方法, 而在这个类最终被调用的方法首先会检查是否传入了 <code>placeholderImage</code> 以及对应的参数, 并设置 <code>placeholderImage</code> .<br>然后会获取 <code>SDWebImageManager</code> 中的单例调用一个 <code>downloadImageWithURL:...</code> 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 <code>SDWebImageCache</code> 中寻找图片是否有对应的缓存, 它会以 <code>url</code> 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 <code>MD5</code> 处理过的 <code>key</code> 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.<br>然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一  个 <code>SDWebImageDownloader</code> 对象的方法 <code>downloadImageWithURL:...</code> 来下载图片, 这个方法会在执行的过程中调用另一个方法 <code>addProgressCallback:andCompletedBlock:fotURL:createCallback:</code> 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 <code>NSMutableURLRequest</code> 和 <code>SDWebImageDownloaderOperation</code> , 并将后者加入 downloader 持有的下载队列开始图片的异步下载.<br>而在图片下载完成之后, 就会在主线程设置 <code>image</code>, 完成整个图像的异步下载和配置.</p><h2 id="12-你一般是怎么用Instruments的？（工作经验的问题，没必要所有都答）"><a href="#12-你一般是怎么用Instruments的？（工作经验的问题，没必要所有都答）" class="headerlink" title="12. 你一般是怎么用Instruments的？（工作经验的问题，没必要所有都答）"></a>12. 你一般是怎么用<code>Instruments</code>的？（工作经验的问题，没必要所有都答）</h2><p><strong>参考答案：</strong></p><ul><li>使用<code>Allocations</code>来检测内存和堆栈信息</li><li>使用<code>Leaks</code>检测内存的使用情况，包括内存泄露问题</li><li>使用<code>Zombies</code>来检测过早释放的僵尸对象，通过它可以检测出在哪里崩溃的。</li><li>使用<code>Time Profiler</code>来检测<code>CPU</code>内存使用情况，性能分析</li></ul><h2 id="13-performSelector-withObject-afterDelay-内部大概是怎么实现的，有什么注意事项么？"><a href="#13-performSelector-withObject-afterDelay-内部大概是怎么实现的，有什么注意事项么？" class="headerlink" title="13. performSelector:withObject:afterDelay:内部大概是怎么实现的，有什么注意事项么？"></a>13. <code>performSelector:withObject:afterDelay:</code>内部大概是怎么实现的，有什么注意事项么？</h2><ul><li><p>创建一个定时器,时间结束后系统会使用runtime通过方法名称(Selector本质就是方法名称)去方法列表中找到对应的方法实现并调用方法</p><p>注意事项</p></li><li><p>调用<code>performSelector:withObject:afterDelay:</code>方法时,先判断希望调用的方法是否存在<code>respondsToSelector:</code></p></li><li>这个方法是异步方法,必须在主线程调用,在子线程调用永远不会调用到想调用的方法</li></ul><h2 id="14-有哪些常见的-Crash-场景？"><a href="#14-有哪些常见的-Crash-场景？" class="headerlink" title="14. 有哪些常见的 Crash 场景？"></a>14. 有哪些常见的 <code>Crash</code> 场景？</h2><ul><li>访问了僵尸对象</li><li>访问了不存在的方法</li><li>数组越界</li><li>在定时器下一次回调前将定时器释放,会Crash</li></ul><h2 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-多线程的实现方式；&quot;&gt;&lt;a href=&quot;#1-多线程的实现方式；&quot; class=&quot;headerlink&quot; title=&quot;1. 多线程的实现方式；&quot;&gt;&lt;/a&gt;1. 多线程的实现方式；&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/20160313/Snip20160313_1.png&quot; alt=&quot;iOS中实现多线程的方案有4种&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="面试" scheme="http://blog.developerly.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Objective-C" scheme="http://blog.developerly.net/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>点击状态栏，滚动视图返回顶部的实现原理</title>
    <link href="http://blog.developerly.net/2016/02/27/%E7%82%B9%E5%87%BB%E7%8A%B6%E6%80%81%E6%A0%8F%EF%BC%8C%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.developerly.net/2016/02/27/点击状态栏，滚动视图返回顶部的实现原理/</id>
    <published>2016-02-27T08:09:48.000Z</published>
    <updated>2017-12-19T04:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p> 在iOS开发中，我们常常看到好多应用都有这样一个效果，如果一个应用当前页是是一个滚动视图，当用户点击状态栏的时候，滚动视图会自动的返回内容的最顶部。<br>其实这个功能是<code>UIScrollView</code>自带的，不需要我们手动去实现，只需要设置<code>self.scrollView.scrollsToTop = YES</code>即可（<code>scrollsToTop</code>默认为<code>YES</code>）。但是这个属性有一个前提是窗口下必须只有一个可滚动的<code>View</code>才有效果。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top, but only if its `scrollsToTop` property is YES, its delegate does not return NO from `shouldScrollViewScrollToTop`, and it is not already at the top.</span><br><span class="line">// On iPhone, we execute this gesture only if there&apos;s one on-screen scroll view with `scrollsToTop` == YES. If more than one is found, none will be scrolled.</span><br></pre></td></tr></table></figure><p>在实际应用中，我们可能会有多个<code>scrollView</code>（包含<code>UITableView/UICollectionView</code>），如网易新闻、爱奇艺，腾讯视频等等应用，这时候，系统默认的点击状态栏返回到顶部效果就会失效，原因是当前<code>window</code>下多个<code>scrollView</code>的<code>scrollsToTop</code>属性的值都是<code>YES</code>,系统不知道该让哪一个<code>scrollView</code>滚动到顶部，所以就什么也不干了。如果还要让当前视图滚回顶部，只需要将除了当前显示的其它<code>scrollView</code>的<code>scrollsToTop</code>属性设置成<code>NO</code>就行。</p><p>但是今天要讲的是应网友要求，讲一下自定义控件来实现此功能。就是《<a href="https://github.com/DeveloperLY/LYTopWindow" target="_blank" rel="noopener">LYTopWindow</a>》实现原理。</p><h1 id="二、基本思路"><a href="#二、基本思路" class="headerlink" title="二、基本思路"></a>二、基本思路</h1><ol><li>获取当状态栏的点击事件</li><li>取得当前<code>window</code>上显示的<code>scrollView</code></li><li>控制<code>scrollView</code>的偏移量，让其滚动到顶部</li></ol><h1 id="三、实现步骤"><a href="#三、实现步骤" class="headerlink" title="三、实现步骤"></a>三、实现步骤</h1><p>新建一个空白项目，我们可以查看应用结构可以知道，状态栏是独立出来的，并不在window上<br><img src="/images/20160227/Snip20160227_1.png" alt="空白应用"></p><p>所以我们不能拿到状态栏直接操作，那么就需要自定义一个控件盖在状态栏上面，用来拦截状态栏的点击事件。</p><h3 id="一、添加窗口"><a href="#一、添加窗口" class="headerlink" title="一、添加窗口"></a>一、添加窗口</h3><p>由于添加普通的控件都不能盖在状态栏上面，所有要新建一个普通的<code>window</code>（<code>keyWindow</code>只能有一个）盖到状态栏的上面。</p><ul><li>在<code>AppDelegate</code>创建一个新的窗口,从<code>iOS9.0</code>开始，程序启动结束时的窗口都必须设置<code>rootViewController</code>。否则会报以下错误：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application windows are expected to have a root view controller at the end of application launch</span><br></pre></td></tr></table></figure><p>这里可以通过<code>dispatch_after</code>来给添加窗口一个延时就可以不设置根控制器而不会报错</p><ul><li><code>UIWindow</code>的显示不需要添加到其它控件上，只需要将<code>hidden</code>设置成<code>NO</code>就行。</li><li>要想让自定义窗口盖在状态栏的上面还要设置窗口的级别<code>windowLevel</code>，窗口的级别有三种，分别是<code>UIWindowLevelAlert &gt; UIWindowLevelStatusBar &gt; UIWindowLevelNormal</code>，级别越高就越显示在顶部，如果级别一样，那么后创建添加的显示在顶部。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static UIWindow *topWindow_;</span><br><span class="line">-(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        topWindow_ = [[UIWindow alloc] init];</span><br><span class="line">        topWindow_.frame = [UIApplication sharedApplication].statusBarFrame;</span><br><span class="line">        topWindow_.backgroundColor = [UIColor clearColor];</span><br><span class="line">        topWindow_.hidden = NO;</span><br><span class="line">        topWindow_.windowLevel = UIWindowLevelAlert;</span><br><span class="line">    &#125;);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在给<code>topWindow</code>添加一个手势监听点击事件就可以拦截到状态栏的点击事件了。<br>但是，这样写会有一个Bug,如果旋转屏幕的话，<code>window</code>上的添加的<code>View</code>的<code>frame</code>不会跟着屏幕旋转而改变，就会不正确。</p><ul><li>如果需要屏幕旋转的话，必须要给<code>UIWindwo</code>设置<code>rootViewController</code>；</li><li>Bug产生的原因是<code>Autoresizing</code>的影响，在旋转的屏幕时，窗口的<code>View</code>宽高被拉伸而造成<code>frame</code>不正确，这时只需要设置一下<code>View</code>跟随窗口的变化而变化即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topWindow_.rootViewController.view.autoresizingMask = UIViewAutoresizingFlexibleWidth;</span><br></pre></td></tr></table></figure><p>居然这里已经设置了<code>rootViewController</code>，那么就不需要<code>dispatch_after</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static UIWindow *topWindow_;</span><br><span class="line">-(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    topWindow_ = [[UIWindow alloc] init];</span><br><span class="line">    topWindow_.frame = [UIApplication sharedApplication].statusBarFrame;</span><br><span class="line">    topWindow_.backgroundColor = [UIColor clearColor];</span><br><span class="line">    topWindow_.hidden = NO;</span><br><span class="line">    topWindow_.windowLevel = UIWindowLevelAlert;</span><br><span class="line">    [topWindow_ addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(topWindowClick)]];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、监听顶部窗口点击，实现当前滚动视图滚回顶部"><a href="#二、监听顶部窗口点击，实现当前滚动视图滚回顶部" class="headerlink" title="二、监听顶部窗口点击，实现当前滚动视图滚回顶部"></a>二、监听顶部窗口点击，实现当前滚动视图滚回顶部</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** * 监听顶部窗口点击 */</span><br><span class="line">+ (void)topWindowClick &#123;</span><br><span class="line">    UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    [self searchAllScrollViewsInView:keyWindow];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找当前<code>keyWindow</code>上的滚动视图,如果跟<code>keyWindow</code>重叠，就让其滚动到顶部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  查找view中的所有scrollView</span><br><span class="line"> */</span><br><span class="line">- (void)searchAllScrollViewsInView:(UIView *)view &#123;</span><br><span class="line">    // 如果不在UIWindow矩形框里面，就直接返回</span><br><span class="line">    // view和UIWindow没有重叠，就直接返回</span><br><span class="line">    if (![view intersectWithView:nil]) return;</span><br><span class="line">    </span><br><span class="line">    for (UIView *subview in view.subviews) &#123;</span><br><span class="line">        [self searchAllScrollViewsInView:subview];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果不是UIScrollView, 直接返回</span><br><span class="line">    if (![view isKindOfClass:[UIScrollView class]]) return;</span><br><span class="line">    </span><br><span class="line">    UIScrollView *scrollView = (UIScrollView *)view;</span><br><span class="line">    </span><br><span class="line">    // 让UIScrollView滚动到最前面</span><br><span class="line">    CGPoint offset = scrollView.contentOffset;</span><br><span class="line">    offset.y = - scrollView.contentInset.top;</span><br><span class="line">    [scrollView setContentOffset:offset animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LYTopWindow的基本实现原理就是这样了，如果想看了解基本实现步骤可以查看LYTopWindow的源代码：<a href="https://github.com/DeveloperLY/LYTopWindow" target="_blank" rel="noopener">https://github.com/DeveloperLY/LYTopWindow</a> 。</p><h3 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h3><p>如果使用了自定义控件实现了点击状态栏滚动视图自动滚回顶部，那么控制器的这两个方法会失效：</p><ol><li>控制器的<code>- (BOOL)prefersStatusBarHidden</code>方法决定状态栏的可见性</li><li>控制器的<code>- (UIStatusBarStyle)preferredStatusBarStyle</code>方法决定状态栏的样式</li></ol><p>原因就是状态栏的样式\可见性，由最顶层（盖在最上面）<code>window</code>的控制器来决定<br>所以如果使用了<a href="https://github.com/DeveloperLY/LYTopWindow" target="_blank" rel="noopener">LYTopWindwo</a>框架的，如果要控制状态栏的样式和可见性可以使用下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 可见性</span><br><span class="line">[LYTopWindow sharedTopWindow].statusBarHidden = NO;</span><br><span class="line">[LYTopWindow sharedTopWindow].statusBarHidden = YES;</span><br><span class="line">   </span><br><span class="line">// 样式</span><br><span class="line">[LYTopWindow sharedTopWindow].statusBarStyle = UIStatusBarStyleDefault;</span><br><span class="line">[LYTopWindow sharedTopWindow].statusBarStyle = UIStatusBarStyleLightContent;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt; 在iOS开发中，我们常常看到好多应用都有这样一个效果，如果一个应用当前页是是一个滚动视图，当用户点击状态栏的时候，滚动视图会自动的返回内容的最顶部。&lt;br&gt;其实这个功能是&lt;code&gt;UIScrollView&lt;/code&gt;自带的，不需要我们手动去实现，只需要设置&lt;code&gt;self.scrollView.scrollsToTop = YES&lt;/code&gt;即可（&lt;code&gt;scrollsToTop&lt;/code&gt;默认为&lt;code&gt;YES&lt;/code&gt;）。但是这个属性有一个前提是窗口下必须只有一个可滚动的&lt;code&gt;View&lt;/code&gt;才有效果。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="UIScrollView" scheme="http://blog.developerly.net/tags/UIScrollView/"/>
    
      <category term="LYTopWindwo" scheme="http://blog.developerly.net/tags/LYTopWindwo/"/>
    
  </entry>
  
  <entry>
    <title>一行代码集成点击状态栏，滚动视图当前内容滚动到顶部</title>
    <link href="http://blog.developerly.net/2016/02/22/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%9B%86%E6%88%90%E7%82%B9%E5%87%BB%E7%8A%B6%E6%80%81%E6%A0%8F%EF%BC%8C%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E5%BD%93%E5%89%8D%E5%86%85%E5%AE%B9%E6%BB%9A%E5%8A%A8%E5%88%B0%E9%A1%B6%E9%83%A8/"/>
    <id>http://blog.developerly.net/2016/02/22/一行代码集成点击状态栏，滚动视图当前内容滚动到顶部/</id>
    <published>2016-02-22T07:08:23.000Z</published>
    <updated>2017-12-19T04:37:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="只有一个ScrollView的时候"><a href="#只有一个ScrollView的时候" class="headerlink" title="只有一个ScrollView的时候"></a>只有一个ScrollView的时候</h1><p>我们在使用App的时候，经常会看到这样的效果，当我们点击状态栏的时候，我们已经滚动过的内容，会自动的滚回顶部，例如：设置界面:</p><p><img src="/images/20160222/Gif20160222_01.gif" alt="设置界面效果"></p><a id="more"></a><p>其实这个功能是系统默认实现的，不需要自己写代码。<br>当点击状态栏的时候自动滚回顶部是因为<code>UIScrollView</code>的<code>scrollsToTop</code>的属性为<code>YSE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic) BOOL  scrollsToTop __TVOS_PROHIBITED;          // default is YES.</span><br></pre></td></tr></table></figure><p>居然系统已经实现了这个功能，那么为什么还要自己实现呢？<br>这个是因为，系统实现的是有缺陷的。</p><h1 id="当ScrollView超过一个的时候"><a href="#当ScrollView超过一个的时候" class="headerlink" title="当ScrollView超过一个的时候"></a>当ScrollView超过一个的时候</h1><p>下面是苹果对scrollsToTop属性的解析说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top, but only if its `scrollsToTop` property is YES, its delegate does not return NO from `shouldScrollViewScrollToTop`, and it is not already at the top.</span><br><span class="line">// On iPhone, we execute this gesture only if there&apos;s one on-screen scroll view with `scrollsToTop` == YES. If more than one is found, none will be scrolled.</span><br></pre></td></tr></table></figure><p>那就是当前视图下，超过一个ScrollView的时候，即使你将scrollsToTop的值设置为YES，但是在点击状态栏的时候，不会有一个ScrollView会滚动到顶部。<br><img src="/images/20160222/Gif20160222_02.gif" alt="多个ScrollView的时候"></p><p>这个时候，如果我们需要这个功能，那么就要我们手动实现了。<br>针对这个，我封装了一个小框架“<a href="https://github.com/DeveloperLY/LYTopWindow" target="_blank" rel="noopener">一行代码完成“点击状态栏滚动视图当前内容滚动到顶部</a>”，框架集成了CocoaPods，方便使用，一行代码可以实现这个小功能。</p><h1 id="使用LYTopWindow"><a href="#使用LYTopWindow" class="headerlink" title="使用LYTopWindow"></a>使用LYTopWindow</h1><h3 id="第一步：使用CocoaPods导入LYTopWindow"><a href="#第一步：使用CocoaPods导入LYTopWindow" class="headerlink" title="第一步：使用CocoaPods导入LYTopWindow"></a>第一步：使用CocoaPods导入LYTopWindow</h3><p>在 <code>Podfile</code> 中进行如下导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;LYTopWindow&apos;</span><br></pre></td></tr></table></figure><p>然后使用 <code>cocoaPods</code> 进行安装：</p><p>如果尚未安装<code>CocoaPods</code>, 运行以下命令进行安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install cocoapods</span><br></pre></td></tr></table></figure><p>安装成功后就可以安装依赖了：</p><p>建议使用如下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 禁止升级CocoaPods的spec仓库，否则会卡在 Analyzing dependencies ，非常慢 </span><br><span class="line">pod update --verbose --no-repo-update</span><br></pre></td></tr></table></figure><p>如果提示找不到库，则可去掉<code>--no-repo-update</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure><h3 id="第二步：集成点击状态栏当前内容滚动到顶部"><a href="#第二步：集成点击状态栏当前内容滚动到顶部" class="headerlink" title="第二步：集成点击状态栏当前内容滚动到顶部"></a>第二步：集成点击状态栏当前内容滚动到顶部</h3><p>导入头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;LYTopWindow.h&gt;</span><br></pre></td></tr></table></figure><p>在AppDelegate.m中方法application:didFinishLaunchingWithOptions:中添加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[LYTopWindow sharedTopWindow] setClickStatusBarBlock:^&#123;</span><br><span class="line">// 让keyWindow上的ScrollView滚动到顶部</span><br><span class="line">[[LYTopWindow sharedTopWindow] searchAllScrollViewsInView:[UIApplication sharedApplication].keyWindow];</span><br><span class="line">        </span><br><span class="line">// 如果需要实现点击状态栏，实现其他功能，可用在这里编写功能代码</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>注意：如果需要实现其他功能效果，可以将这句代码替换成其他需要的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[LYTopWindow sharedTopWindow] searchAllScrollViewsInView:[UIApplication sharedApplication].keyWindow];</span><br></pre></td></tr></table></figure><p><img src="/images/20160222/Gif20160222_03.gif" alt="使用LYTopWindow后的效果图"></p><p>框架里面有个小Demo，可以自行实验，欢迎Issues<br><a href="https://github.com/DeveloperLY/LYTopWindow" target="_blank" rel="noopener">LYTopWindow</a>地址：<a href="https://github.com/DeveloperLY/LYTopWindow" target="_blank" rel="noopener">https://github.com/DeveloperLY/LYTopWindow</a><br>如果想了解LYTopWindow的实现原理，可以查看我的另一篇文章《<a href="http://www.jianshu.com/p/b5d01f760d7b" target="_blank" rel="noopener">点击状态栏，滚动视图返回顶部的实现</a>》</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;只有一个ScrollView的时候&quot;&gt;&lt;a href=&quot;#只有一个ScrollView的时候&quot; class=&quot;headerlink&quot; title=&quot;只有一个ScrollView的时候&quot;&gt;&lt;/a&gt;只有一个ScrollView的时候&lt;/h1&gt;&lt;p&gt;我们在使用App的时候，经常会看到这样的效果，当我们点击状态栏的时候，我们已经滚动过的内容，会自动的滚回顶部，例如：设置界面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20160222/Gif20160222_01.gif&quot; alt=&quot;设置界面效果&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="UIScrollView" scheme="http://blog.developerly.net/tags/UIScrollView/"/>
    
      <category term="scrollsToTop" scheme="http://blog.developerly.net/tags/scrollsToTop/"/>
    
      <category term="LYTopWindow" scheme="http://blog.developerly.net/tags/LYTopWindow/"/>
    
  </entry>
  
  <entry>
    <title>为Xcode添加删除当前行、复制当前行快捷键</title>
    <link href="http://blog.developerly.net/2016/01/18/%E4%B8%BAXcode%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E8%A1%8C%E3%80%81%E5%A4%8D%E5%88%B6%E5%BD%93%E5%89%8D%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://blog.developerly.net/2016/01/18/为Xcode添加删除当前行、复制当前行快捷键/</id>
    <published>2016-01-18T12:44:50.000Z</published>
    <updated>2017-12-18T19:45:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在做JAVA开发时,使用eclipse过程中,用的最多也是特喜欢的就是删除当前行和复制当前行的快捷键。然而在转向iOS开发时,Xcode是不支持这两个快捷键的,一次偶然发现有个小窍门可以为Xcode来添加这两个快捷键。</p><a id="more"></a><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><ul><li>修改<code>Xcode</code>里快捷键的配置文件<code>(plist)</code>的权限,在终端中输入下面两条命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br><span class="line">sudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/</span><br></pre></td></tr></table></figure><h2 id="添加快捷方式"><a href="#添加快捷方式" class="headerlink" title="添加快捷方式"></a>添加快捷方式</h2><ul><li>权限修改完成后,在终端中输入下面的命令,打开<code>plist</code>文件修改(默认是Xcode打开)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br></pre></td></tr></table></figure><h3 id="添加删除当前行"><a href="#添加删除当前行" class="headerlink" title="添加删除当前行"></a>添加删除当前行</h3><ul><li>找到<code>root</code>下的<code>Deletions</code>,在<code>Deletions</code>下添加一个item:<ul><li>key:<code>Delete Current Line</code></li><li>value:<code>deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:</code></li></ul></li></ul><h3 id="添加复制当前行"><a href="#添加复制当前行" class="headerlink" title="添加复制当前行"></a>添加复制当前行</h3><ul><li>在<code>Insertions and Indentations</code>下添加两个item:<ul><li>key:<code>Duplicate Current Line</code> value:<code>selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:</code></li><li>key:<code>Insert Line Under</code>  value:<code>moveToEndOfLine:, insertNewline:</code></li></ul></li><li>如图<br><img src="/images/20160118/Snip20160118_1.png" alt="Snip20160118_1.png"></li></ul><h2 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h2><ul><li>最重要的部分来了, 重启<code>Xcode</code>, 然后在<code>preferences</code>里找到<code>Key Bindings</code>,在搜索框中输入<code>current</code>,可以快速定位到<code>Delete Current Line</code>和<code>Duplicate Current Line</code>两个选项,只要设置自己喜欢的快捷键即可。</li><li>如图:<br><img src="/images/20160118/Snip20160118_2.png" alt="Snip20160118_2.png"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在做JAVA开发时,使用eclipse过程中,用的最多也是特喜欢的就是删除当前行和复制当前行的快捷键。然而在转向iOS开发时,Xcode是不支持这两个快捷键的,一次偶然发现有个小窍门可以为Xcode来添加这两个快捷键。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.developerly.net/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.developerly.net/tags/iOS/"/>
    
      <category term="Xcode" scheme="http://blog.developerly.net/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>吱一声</title>
    <link href="http://blog.developerly.net/2016/01/16/%E5%90%B1%E4%B8%80%E5%A3%B0/"/>
    <id>http://blog.developerly.net/2016/01/16/吱一声/</id>
    <published>2016-01-15T17:18:29.000Z</published>
    <updated>2017-12-25T16:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>想我也不是那种写博客的人(很久以前<a href="http://my.csdn.net/u011619223?locationNum=0&amp;fps=1" target="_blank" rel="noopener">CSDN</a>地址)，但作为一枚程序猿没有个自己的博客，貌似很OUT~~。</p><p>博客是部署到GitHub上的，用的是Hexo，很方便就搭起来了~</p><p>只是存在的时间有多长，就不得而知啦~~</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想我也不是那种写博客的人(很久以前&lt;a href=&quot;http://my.csdn.net/u011619223?locationNum=0&amp;amp;fps=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;地址)，但作为一枚程序猿没有个自己的博客，貌似很OUT~~。&lt;/p&gt;
&lt;p&gt;博客是部署到GitHub上的，用的是Hexo，很方便就搭起来了~&lt;/p&gt;
&lt;p&gt;只是存在的时间有多长，就不得而知啦~~&lt;/p&gt;
    
    </summary>
    
      <category term="吐槽" scheme="http://blog.developerly.net/categories/%E5%90%90%E6%A7%BD/"/>
    
    
      <category term="吐槽" scheme="http://blog.developerly.net/tags/%E5%90%90%E6%A7%BD/"/>
    
      <category term="GitHub" scheme="http://blog.developerly.net/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://blog.developerly.net/tags/Hexo/"/>
    
  </entry>
  
</feed>
