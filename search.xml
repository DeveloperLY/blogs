<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Mac自动操作制作@1x@2x@3x图片（切图）]]></title>
    <url>%2F2019%2F07%2F20%2F%E4%BD%BF%E7%94%A8Mac%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E5%88%B6%E4%BD%9C-1x-2x-3x%E5%9B%BE%E7%89%87%EF%BC%88%E5%88%87%E5%9B%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在iOS开发中，使用的图片要求导入@1x、@2x和@3x: 使用@1x格式：iPhone3GS（基本上是淘汰了） 使用@2x格式：iPhone 4，4S，5，5S，5C，SE，6，6S，7，8，XR 使用@3x格式：iPhone 6Plus、6sPlus、7Plus、8Plus、X、XS、XS Max 这样在开发过程中，将三种图片（比如分别为【xxx.png】、【xxx@2x.png】 和 【xxx@3x.png】）导入到工程图库中的时候可以自动被识别为1x、2x和3x大小的图片 可以利用Mac系统中自带的服务自己制作一个快速生成@1x、@2x和@3x图片的功能 首先spotlight搜索Automator，然后按Enter打开 新建文稿 选取文稿类型为快速操作 在工作流程收到当前的后面选择图像文件 在左边窗口的“操作”下，选择“资源库”中的“文件和文件夹”，将右侧中的“给访达项目重新命名”拖入最右侧的窗口中，（如果警告提示是否要增加一个“拷贝访达项目”操作，选择“不添加”），选择“添加文本”，在输入框中输入【@3x】 拖入“复制访达项目” 选择左侧“资源库”中的照片，将“缩放图像”拖入右侧窗口（如果警告提示是否要增加一个“拷贝访达项目”操作，选择“不添加”），并选择“按百分比”，输入【66】 再拖入“文件和文件夹”下的“给访达项目重新命名”，（如果警告提示是否要增加一个“拷贝访达项目”操作，选择“不添加”）并选择【替换文本】，查找【“】，以【仅基本名称】；再拖入“文件和文件夹”下的“给访达项目重新命名”，并选择【替换文本】，查找【@3x”的副本】，以【仅基本名称】，替换成【@2x】 拖入“复制访达项目”，选择左侧“资源库”中的照片，将“缩放图像”拖入右侧窗口（如果警告提示是否要增加一个“拷贝访达项目”操作，选择“不添加”），并选择“按百分比”，输入【50】 再拖入“文件和文件夹”下的“给访达项目重新命名”，（如果警告提示是否要增加一个“拷贝访达项目”操作，选择“不添加”）并选择【替换文本】，查找【“】，以【仅基本名称】，再拖入“文件和文件夹”下的“给访达项目重新命名”，并选择【替换文本】，查找【@2x”的副本】，以【仅基本名称】 然后保存，将“快速操作”存储为“制作@2x@3x图片” 每次使用的时候，只需选中图片，选择访达 -&gt; 服务 -&gt; 制作@2x@3x图片，就会自动生成三个图片：【xxx.png】、【xxx@2x.png】和【xxx@3x.png】 或者选择图片，右键服务 -&gt; 制作@2x@3x图片一样会自动生成三个图片：【xxx.png】、【xxx@2x.png】 和 【xxx@3x.png】 注意：这里3x的图片是当前图片，也就制作的原图就是3x的； 最终效果~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
        <tag>UI</tag>
        <tag>切图</tag>
        <tag>自动操作</tag>
        <tag>Automator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TabBar 的 Item 按钮的像素大小]]></title>
    <url>%2F2019%2F01%2F20%2FTabBar%20%E7%9A%84%20Item%20%E6%8C%89%E9%92%AE%E7%9A%84%E5%83%8F%E7%B4%A0%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[TabBar的Item按钮的像素大小要求根据苹果官方人机界面指南（Human Interface Guidelines）可以得知： iOS系统会根据设备和方向显示两种标签栏：常规（Regular）和紧凑（Compact），所以在设置自定义TabBar Item的时候也应该包含常规和紧凑两种不同的尺寸～ 根据图形是圆形、方形、宽形、高形，像素也有不同的要求： 如果图标是圆形的，应该提供：25pt@2x、25pt@3x、18pt@2x、18pt@3x 如果图标是方形的，应该提供：23pt@2x、23pt@3x、17pt@2x、17pt@3x 如果图标是宽形的，应该提供：31pt@2x、31pt@3x、23pt@2x、23pt@3x 如果图标是高形的，应该提供：28pt@2x、28pt@3x、20pt@2x、20pt@3x 完整表格~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂度分析]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、概念算法复杂度是指算法在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和内存资源。应用于数学和计算机导论。 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。 学习数据结构和算法，就一定离不开时间、空间复杂度分析。复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。 二、为什么需要复杂度分析 预测算法所需要的资源 计算时间（CPU消耗） 内存空间（RAM消耗） 通信时间（带宽消耗） 预测算法的运行时间 在给定输入规模时，所执行的基本操作数量 或者称之为算法复杂度（Algorithm Complexity） 测试结果非常依赖测试环境 测试环境中硬件的不同对测试结果有很大的影响 测试结果受到数据规模的影响很大 对于小规模的数据排序，插入排序可能反倒会比快速排序要快 所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。这就是时间、空间复杂度分析方法。 三、大 O 复杂度表示法大O表示法就是将算法的所有步骤转换为代数项，然后排除不会对问题的整体复杂度产生较大影响的较低阶常数和系数。 一起来估算下面的代码执行时间，求1，2，3…n的累加和： 12345678int cal(int n) &#123; int sum = 0; int i = 0; for (; i &lt;= n; ++i) &#123; sum = sum + i; &#125; return sum;&#125; 从CPU的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的CPU执行的个数、执行的时间都不一样，但是，这里只是粗略的估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设基础之上，这段代码的总执行时间是多少呢？第 2、3 行代码分别需要1个unit_time的执行时间，第 4、5 行都运行了n遍，所以需要2n * unit_time的执行时间，所以这段代码总的执行时间就是(2n + 2) * unit_time。可以看出来，所有代码的执行时间T(n)与每行代码的执行次数成正比。 按照这个分析思路，再来看下面这段代码 1234567891011int cal(int n) &#123; int sum = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) &#123; j = 1; for (; j &lt;= n; ++j) &#123; sum = sum + j * j; &#125; &#125;&#125; 依旧假设每个语句的执行时间是unit_time。那这段代码的总执行时间T(n)是多少呢？第 2、3、4 行代码，每行都需要 1 个 unit_time 执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n * unit_time 的执行时间，第 7、8 行代码循环执行了 n2 遍，所以需要 2n2 unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n2 + 2n + 3) unit_time。 尽管不知道 unit_time 的具体值，但是通过上面两段代码的执行时间的推导过程，可以得到一个非常重要的规律，那就是：所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。 这个规律总结成公式就是： T(n) 表示代码执行的时间； n 表示数据规模的大小； f(n) 表示每行代码执行的次数总和（因为是一个公式，所以用f(n)来表示）； O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比； 所以，第一个例子中的 T(n) = O(2n + 2)，第二个例子中的 T(n) = O(2n2 + 2n + 3)。 这就是大 O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随着数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。 当 n 很大时，比如10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚才的两段代码的时间复杂度，就可以记为: T(n) = O(n)；T(n) = O(n2)。 四、时间复杂度分析1.只关注循环执行次数最多的一段代码刚才说了， 大 O 这种复杂度表示法只是表示一种变化趋势。通常会忽略掉公司中的常量、低价、系数，只需要记录一个最大阶量级就可以了，所有在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度如果T1(n) = O(f(n))，T2(n) = O(g(n))；那么T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))。 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积如果 T1(n) = O(f(n))，T2(n) = O(g(n))；那么 T(n) = T1(n)T2(n) = O(f(n))O(g(n)) = O(f(n)g(n))。也就是说，假设 T1(n) = O(n), T2(n) = O(n2)，则T1(n) T2(n) = O(n3)。 五、几种常见时间复杂度实例分析虽然代码千差万别，但是常见的复杂度量级并不多。 上面罗列的复杂度量级，可以粗略的分为两类，多项式量级和非多项式量级。其中非多项式量级只有两个：O(2n) 和 O(n!)。 当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以非多项式时间复杂度的算法其实是非常低效的算法。 1. O(1)O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。即只要代码的执行时间不随着 n 的增大而增长，这样代码的时间复杂度都记作O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)。 比如：下面代码即便有三行，它的时间复杂度也是O(1)，而不是O(3)。 123int i = 1;int j = 3;int sum = i + j; 2. O(logn)、O(nlogn)对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。 1234i = 1;while (i &lt;= n) &#123; i = i * 2;&#125; 从代码中可以知道，变量 i 的取值就是一个等比数列。 通过 2x = n 求解 x 的公式 x = log2n，所以这段代码的时间复杂度就是O(log2n)。 1234i = 1;while (i &lt;= n) &#123; i = i * 3;&#125; 根据刚才的思路，可以看出这段代码的时间复杂度为O(log3n)实际上不管是以 2 为底、以 3 为底还是以 10 为底，都可以把对数阶的时间复杂度记为 O(logn)。我们知道，对数之间是可以相互转换的，log3n 就等于 log32 log3n， 所以O(log3n) = O(C log2n)，其中 C * log32 是一个常量。基于在采用大 O 标记复杂度的时候可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，忽略对数的“底”，统一表示为 O(logn)。O(nlogn)，如果一段代码的时间复杂度是 O(logn)，循环执行 n 遍，时间复杂度就变成 O(nlogn)了，而且 O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。 3. O(m+n)、O(m*n)再来看一种和前面不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。 123456789101112131415int cal(int m, int n) &#123; int sum_1 = 0; int i = 1; for (; i &lt; m; ++i) &#123; sum_1 = sum_1 + i; &#125; int sum_2 = 0; int j = 1; for (; j &lt; n; ++i) &#123; sum_2 = sum_2 + j; &#125; return sum_1 + sum_2;&#125; 从上面代码中可以看出， m 和 n 是表示两个数据的规模。无法事先评估 m 和 n 谁的量级大，所以在表示时间复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)。 针对这种情况，原来的加法法则就不正确了，我们需要将加法法则改为:T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m) T2(n) = O(f(m) g(n))。 六、空间复杂度分析空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 空间复杂度分析相比时间复杂度分析简单的多，而且常见的空间复杂度就是O(1)、O(n)、O(n2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。 七、总结复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)。]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>时间复杂度、空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法和数据结构]]></title>
    <url>%2F2018%2F12%2F30%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构这门课程是大小计算机系的必修课，很多人第一次接触这门课时，都会觉的数据结构和算法很抽象，晦涩难懂，宛如天书。虽然在大学的时候老师讲的都听明白了，但是毕业后不是专门从事算法相关的工作。所以到现在已经忘记很多了。如果你想让自己的编程能力有质的飞跃，不再停留于调用现成的东西而是追求更完美的实现， 对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！那么数据结构和算法是你的必修课！ 一、什么是数据结构官方定义:数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。 大部分数据结构和算法的教材，都会给这两个概念明确一下定义， 但是这些定义都很抽象，对理解这两个概念并没有实质性的帮助，反倒会让你陷入死抠定义的误区。虽然我们说没必要深挖严格的定义，但是这并不等于不需要理解概念。 广义上讲数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。 狭义上讲是指某些著名的数据结构和算法，比如队列、栈、二分查找、动态规划等。 二、数据结构和算法的关系大部分的书和教程都会把数据结构和算法这两个东西放到一起讲，这是因为数据结构和算法是相辅相成的。数据机构是为算法服务的，算法要作用在特定的数据结构之上。 比如，常用的二分查找算法需要用数组来存储数据，因为数组具有随机访问的特点。但是如果选用链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。 数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立的数据结构就是没有用的。 数据结构和算法涵盖的内容 20个最常用的、最基础的数据结构和算法：10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。 不管是应付面试还是工作需要，只要集中精力逐一攻克这 20 个知识点就足够了。而且掌握了这些基础的数据结构和算法，再去学更加复杂的数据结构和算法，就会非常容易、非常快。 学习数据结构和算法的过程，是非常好的思维训练的过程，所以，千万不要被动的记忆，要多辩证地思考，多问为什么。如果你一直这么坚持做，你会发现，等你学完之后，写代码的时候就会不由自主地考虑到很多性能方面的事情，时间复杂度、空间复杂度非常高的垃圾代码出现的次数就会越来越少。你的汇编内功就真正得到了修炼。]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构和算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLVM-Clang插件开发]]></title>
    <url>%2F2018%2F09%2F13%2FLLVM-Clang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[前言前面一篇博客介绍了LLVM相关内容，那现在就开始用学到的LLVM知识，做一下实践； –Clang插件开发 一、插件目录 在【clang/tools】源码目录下新建一个插件目录，叫做【ly-plugin】(自定义) 在【clang/tools/CMakeLists.txt】最后加入内容： add_clang_subdirectory(ly -plugin)，小括号里是插件目录名 二、插件必要的文件 在【ly-plugin】目录下新建一个【CMakeLists.txt】，文件内容是：add_llvm_loadable_module(LYPlugin LYPlugin.cpp) 三、编写插件源码 【LYPlugin.cpp】参考 四、编译插件 利用cmake生成的Xcode项目来编译插件（第一次编写完插件，需要利用cmake重新生成一下Xcode项目） 插件源代码在【Sources/Loadable modules】目录下可以找到，这样就可以直接在Xcode里编写插件代码 选择LYPlugin这个target进行编译，编译完会生成一个动态库文件 五、加载插件 在Xcode项目中指定加载插件动态库：Build Settings &gt; OTHER_CFLAGS -Xclang -load -Xclang 动态库路径 -Xclang -add-plugin -Xclang 插件名称 六、Hack Xcode 首先要对Xcode进行Hack，才能修改默认的编译器 下载【XcodeHacking.zip】，解压，修改【HackedClang.xcplugin/Contents/Resources/HackedClang.xcspec】的内容，设置一下自己编译好的clang的路径 然后在XcodeHacking目录下进行命令行，将XcodeHacking的内容剪切到Xcode内部 1$ sudo mv HackedClang.xcplugin `xcode-select-printpath`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins 1$ sudo mv HackedBuildSystem.xcspec `xcode-select-printpath`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications 七、修改Xcode的编译器 八、编译项目 编译项目后，会在编译日志看到LYPlugin插件的打印信息（如果插件更新了，最好先Clean一下项目） 九、更多 想要实现更复杂的插件功能，就需要利用clang的API针对语法树（AST）进行相应的分析和处理 关于AST的资料 https://clang.llvm.org/doxygen/namespaceclang.html https://clang.llvm.org/doxygen/classclang_1_1Decl.html https://clang.llvm.org/doxygen/classclang_1_1Stmt.html 十、推荐书籍]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>Clang</tag>
        <tag>插件开发</tag>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLVM]]></title>
    <url>%2F2018%2F09%2F12%2FLLVM%2F</url>
    <content type="text"><![CDATA[一、什么是LLVM？ 官网：https://llvm.org/ The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.（LLVM项目是模块化、可重用的编译器以及工具链技术的集合。） 美国计算机协会 (ACM) 将其2012年软件系统奖项颁给了LLVM，之前曾经获得此奖项的软件和技术包括：Java、Apache、 Mosaic、the World Wide Web、Smalltalk、UNIX、Eclipse等等 创始人Chris Lattner，亦是Swift之父; 有些文章把LLVM当做Low Level Virtual Machine（低级虚拟机）的缩写简称，官方描述如下:The name &quot;LLVM&quot; itself is not an acronym; it is the full name of the project.(LLVM这个名称本身不是首字母缩略词; 它是项目的全名) 二、传统的编译器架构和LLVM架构 不同的前端后端使用统一的中间代码LLVM Intermediate Representation(LLVM IR) 如果需要支持一种新的编程语言，那么只需要实现一个新的前端 如果需要支持一种新的硬件设备，那么只需要实现一个新的后端 优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改 相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就变得特别困难 LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构（GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等） 三、Clang 什么是Clang？ LLVM项目的一个子项目 基于LLVM架构的C/C++/Objective-C编译器前端 官网：http://clang.llvm.org/ 相比于GCC，Clang具有如下优点 编译速度快：在某些平台上，Clang的编译速度显著的快过GCC（Debug模式下编译OC速度比GGC快3倍） 占用内存小：Clang生成的AST所占用的内存是GCC的五分之一左右 模块化设计：Clang采用基于库的模块化设计，易于IDE集成及其他用途的重用 诊断信息可读性强：在编译过程中，Clang创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告 设计清晰简单，容易理解，易于扩展增强 四、Clang与LLVM 五、OC源文件的编译过程 命令行查看编译的过程：$ clang -ccc-print-phases main.m 查看preprocessor（预处理）的结果：$ clang -E main.m 六、词法分析 词法分析，生成Token： $ clang -fmodules -E -Xclang -dump-tokens main.m 七、语法树-AST 语法分析，生成语法树（AST，Abstract Syntax Tree）：$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m 八、LLVM IR LLVM IR有3种表示形式（但本质是等价的，就好比水可以有气体、液体、固体3种形态） text：便于阅读的文本格式，类似于汇编语言，拓展名.ll， $ clang -S -emit-llvm main.m memory：内存格式 bitcode：二进制格式，拓展名.bc， $ clang -c -emit-llvm main.m IR基本语法 注释以分号 ; 开头 全局标识符以@开头，局部标识符以%开头 alloca，在当前函数栈帧中分配内存 i32，32bit，4个字节的意思 align，内存对齐 store，写入数据 load，读取数据 官方语法参考 https://llvm.org/docs/LangRef.html 九、源码下载 下载LLVM $ git clone https://git.llvm.org/git/llvm.git/ 大小746.2 MB，仅供参考 下载clang $ cd llvm/tools $ git clone https://git.llvm.org/git/clang.git/ 大小297.7 MB，仅供参考 十、源码编译 安装cmake和ninja（先安装brew，https://brew.sh/） $ brew install cmake $ brew install ninja ninja如果安装失败，可以直接从github获取release版放入【/usr/local/bin】中 https://github.com/ninja-build/ninja/releases 在LLVM源码同级目录下新建一个【llvm_build】目录（最终会在【llvm_build】目录下生成【build.ninja】） $ cd llvm_build $ cmake -G Ninja ../llvm -DCMAKE_INSTALL_PREFIX=LLVM的安装路径 更多cmake相关选项，可以参考：https://llvm.org/docs/CMake.html 依次执行编译、安装指令 $ ninja 编译完毕后，【llvm_build】目录大概21.05 G（仅供参考） $ ninja install 安装完毕后，安装目录大概11.92 G（仅供参考） 也可以生成Xcode项目再进行编译，但是速度很慢（可能需要1个多小时） 在llvm同级目录下新建一个【llvm_xcode】目录 cd llvm_xcode $ cmake -G Xcode ../llvm 十一、应用与实践 libclang、libTooling 官方参考：https://clang.llvm.org/docs/Tooling.html 应用：语法树分析、语言转换等 Clang插件开发 官方参考 https://clang.llvm.org/docs/ClangPlugins.html https://clang.llvm.org/docs/ExternalClangExamples.html https://clang.llvm.org/docs/RAVFrontendAction.html 应用：代码检查（命名规范、代码规范）等 Pass开发 p 官方参考：https://llvm.org/docs/WritingAnLLVMPass.html 应用：代码优化、代码混淆等 开发新的编程语言 https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods私有库使用Tips]]></title>
    <url>%2F2017%2F09%2F11%2FCocoaPods%E7%A7%81%E6%9C%89%E5%BA%93%E4%BD%BF%E7%94%A8Tips%2F</url>
    <content type="text"><![CDATA[1.pod lib lint 和 pod spec lint 命令的区别 pod lib lint是只从本地验证你的pod能否通过验证; pod spec lint是从本地和远程验证你的pod能否通过验证; 2.私有pod的验证使用pod spec lint去验证私有库能否通过验证时应该要添加--sources选项，不然会出现找不到repo的错误: 1pod spec lint --sources='私有仓库repo地址,https://github.com/CocoaPods/Specs' 3.subspec为了让自己的Pod被导入时显示出良好的文件层划分，subspec是必须的。若subspec要依赖其它的subspec，则subspec的dependency后面接的不是目录路径，而是specA/specB这种spec关系； 4.私有库引用私有库的问题在私有库引用了私有库的情况下，在验证和推送私有库的情况下都要加上所有的资源地址，不然Pod会默认从官方repo查询。 12pod spec lint --sources='私有仓库repo地址,https://github.com/CocoaPods/Specs'pod repo push 本地repo名 podspec名 --sources='私有仓库repo地址,https://github.com/CocoaPods/Specs 5.引用自己或第三方的framework或.a文件时在podsepc中应该这样写: 12s.ios.vendored_frameworks = "xxx/**/*.framework"s.ios.vendored_libraries = "xxx/**/*.a” 6.引用静态库：(.ios).library。去掉头尾的lib，用”,”分割12// 引用libxml2.lib和libz.lib.spec.libraries = 'xml2', 'z' 7.引用公有framework：(.ios).framework. 用”,”分割. 去掉尾部的”.framework”1spec.frameworks = 'UIKit','SystemConfiguration', 'Accelerate' 8.引用自己生成的framework：(.ios).vendored_frameworks。用”,”分割,路径写从.podspec所在目录为根目录的相对路径 ps:这个不要省略.framework1spec.ios.vendored_frameworks = 'Pod/Assets/*.framework' 9.引用自己生成的.a文件, 添加到Pod/Assets文件夹里. Demo的Example文件夹里也需要添加一下, 不然找不到1spec.ios.vendored_libraries = 'Pod/Assets/*.a' 在提交到私有仓库的时候需要加上--use-libraries 10.私有库中添加资源(图片、音视频等)方法共有三种: 第一种 1spec.resources = ["Images/*.png", "Sounds/*"] 但是这些资源会在打包的时候直接拷贝的App的Bundle中，这样说不定会和其它资源产生命名冲突； 第二种 1spec.resource = "Resources/MyLibrary.bundle" 把资源都放在bundle中，然后打包时候这个bundle会直接拷贝进App的mainBundle中。使用的时候在mainBundle中查找这个bundle然后再搜索具体资源: 123NSURL *bundleURL = [[NSBundle mainBundle] URLForResource:@&quot;MyLibrary&quot; withExtension:@&quot;bundle&quot;];NSBundle *bundle = [NSBundle bundleWithURL:bundleURL];UIImage *imgage = [UIImage imageNamed:icon inBundle:bundle compatibleWithTraitCollection:nil]; 第三种 1234spec.resource_bundles = &#123;'MyLibrary' =&gt; ['Resources/*.png'],'OtherResources' =&gt; ['OtherResources/*.png']&#125; 这种方法利用framework的命名空间，有效防止了资源冲突。使用方法是先拿到最外面的bundle，然后再去找下面指定名字的bundle 对象，再搜索具体资源: 1234NSBundle *bundle = [NSBundle bundleForClass:[self class]];NSURL *bundleURL = [bundle URLForResource:@&quot;MyLibrary&quot; withExtension:@&quot;bundle&quot;];NSBundle *resourceBundle = [NSBundle bundleWithURL: bundleURL];UIImage *imgage = [UIImage imageNamed:icon inBundle:resourceBundle compatibleWithTraitCollection:nil]; 11.如果私有库添加了静态库或者dependency用了静态库那么执行pod lib lint还有pod spec lint时候需要加上—user-libraries选项,否则会出现&#39;The &#39;Pods&#39; target has transitive dependencies错误 12.如果私有库只引用其他库的subspec只需要依赖想依赖的subspec，不用管主spec（因为依赖subspec必然要依赖主spec） 13.私有库已经通过验证并传到私有repo也能通过pod search，但是就是pod install失败这时候只要执行pod update 14.提交到私有仓库的之前可以先验证一下, 有问题就修复它, 验证过了在提交1pod spec lint VenderName.podspec --verbose 打好tag, 推到Git里去后, 才可以在测试的项目里的Podfile里引用这个库, 然后pod update VenderName --no-repo-update, 测试通过了, 在提交到私有仓库里 1pod 'VenderName', :podspec =&gt; 'VenderName.podspec的路径地址' 还可以指定引用某个分支的代码 1pod 'VenderName', :git =&gt; 'https://git.coding.net/CodingZero/VenderName.git', :branch =&gt; 'develop' 提交到私有仓库的时候还可以忽略警告类的错误, 愣是要提交. 在后面加上--allow-warnings 1pod repo push LYSpecs VenderName.podspec --allow-warnings 如果有添加新的文件, 需要更新下引索, Demo里才可以识别 1pod update VenderName --no-repo-update 15.使用的时候还可以通过直接指定地址 + tag or 分支 or commit 的方式来引入, 这样就可以不用走发布流程了. 也不需要添加源了.12345pod 'VenderName', :git =&gt; 'https://git.coding.net/CodingZero/VenderName.git', :tag =&gt; '0.8.1'pod 'VenderName', :git =&gt; 'https://git.coding.net/CodingZero/VenderName.git', :branch =&gt; 'develop'pod 'VenderName', :git =&gt; 'https://git.coding.net/CodingZero/VenderName.git', :commit =&gt; '0812fe81319af2411233']]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
        <tag>pod</tag>
        <tag>私有库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods私有库Steps]]></title>
    <url>%2F2017%2F09%2F11%2FCocoaPods%E7%A7%81%E6%9C%89%E5%BA%93Steps%2F</url>
    <content type="text"><![CDATA[1.创建私有仓库先coding.net、OSChina、GitHub或者自己搭建的Git服务器上创建一个私有仓库，然后在本地添加仓库 1pod repo add LYSpecs https://git.coding.net/CodingZero/LYSpecs.git 2.创建私有库创建私有库模板 1pod lib create VenderName 第一个问题是问你选择Swift还是Objc构建项目。eg: ObjC 12hat language do you want to use?? [ Swift / ObjC ] &gt; ObjC 第二个问题问你是否需要创建一个Demo项目eg: Yes 12Would you like to include a demo application with your library? [ Yes / No ] &gt; Yes 第三个问题让你是否选择一个测试框架eg: None 12Which testing frameworks will you use? [ Specta / Kiwi / None ]&gt; None 第四个问题是否基于View测试eg: No 12Would you like to do view based testing? [ Yes / No ]&gt; No 第五个问题是询问 类的前缀eg: LY 12What is your class prefix?&gt; LY 3.更新发布私有库 提交代码 1git add -A &amp;&amp; git commit -m "Release 1.0.0" 打tag 1git tag '1.0.0' 把tag推到远程仓库 1git push --tags 将本地的master分支推送到远程仓库 1git push origin master 提交到私有仓库 1234 pod repo push LYSpecs VenderName.podspec --allow-warnings --verbose// --allow-warnings : 允许 警告，有一些警告是代码自身带的。// --use-libraries : 私有库、静态库引用的时候加上// —-verbose ： lint显示详情 4.使用私有库 用的时候需要在Podfile里添加源 123456 // GitHub地址source 'https://github.com/CocoaPods/Specs.git'# ...相关库// 私有库地址source 'https://git.coding.net/CodingZero/LYSpecs.git'# ...私有库 用的时候在Podfile里引用 1pod 'VenderName' 开发模式下测试Pod库的代码 1pod 'VenderName', :path =&gt; '../' # 指定路径 然后在Example工程目录下执行pod update命令安装依赖，打开项目工程，可以看到库文件都被加载到Pods子项目中了不过它们并没有在Pods目录下，而是跟测试项目一样存在于Development Pods/VenderName中，这是因为我们是在本地测试，而没有把podspec文件添加到Spec Repo中的缘故。 5.podspec文件配置说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465## Be sure to run `pod lib lint VenderName.podspec' to ensure this is a# valid spec before submitting.## Any lines starting with a # are optional, but their use is encouraged# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html#Pod::Spec.new do |s| #名称 s.name = 'VenderName' #版本号 s.version = '0.1.0' #简介 s.summary = '这个是我的私有库项目Demo.'# This description is used to generate tags and improve search results.# * Think: What does it do? Why did you write it? What is the focus?# * Try to keep it short, snappy and to the point.# * Write the description between the DESC delimiters below.# * Finally, don't worry about the indent, CocoaPods strips it! s.description = &lt;&lt;-DESC 这个是教程的 私有库项目 学习Demo. （主要：比s.summary要长） DESC #主页,这里要填写可以访问到的地址，不然验证不通过 s.homepage = 'https://coding.net/CodingZero/VenderName' # s.screenshots = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2' #开源协议 s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125; #作者 s.author = &#123; 'DeveloperLY' =&gt; 'coderyliu@gmail.com' &#125; #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS。 #这里的s.source须指向存放源代码的链接地址，而不是托管spec文件的repo地址 s.source = &#123; :git =&gt; 'https://coding.net/CodingZero/VenderName.git', :tag =&gt; "0.1.0" &#125; #s.social_media_url = 'http://weibo.com/lycoder' #支持的平台及版本 s.ios.deployment_target = '7.0' #代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则 #用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置 s.source_files = "VenderName/Classes/**/*" #资源文件地址 # s.resource_bundles = &#123; # 'MyLib' =&gt; ['VenderName/Assets/*.png'] # &#125; #公开头文件地址 #s.public_header_files = 'VenderName/Classes/**/*.h' #所需的framework，多个用逗号隔开 s.frameworks = 'UIKit' #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency # s.dependency 'AFNetworking', '~&gt; 2.3'end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
        <tag>pod</tag>
        <tag>私有库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 快速入门]]></title>
    <url>%2F2017%2F09%2F09%2FSpringBoot-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一、简介Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。 二、Spring Boot 的主要优点： 快速构建独立的Spring应用程序 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目，嵌入Tomcat、Gradle，无需部署WAR包 提供生产就绪功能，如指标，健康检查和外部配置 简化Maven及Gradle配置 没有冗余代码生成和XML配置的要求 对主流开发框架和工具链做无配置集成 三、系统环境 Java 1.8.0_112 Spring Boot 1.5.4 IntelliJ IDEA 2017.1.3 四、快速构建项目1. 使用SPRING INITIALIZR工具生成基础项目1.1 打开浏览器：http://start.spring.io/ 1.2 选择构建工具Maven Project、Java和Spring Boot版本1.5.4以及填 写一下工程基本信息： 1.3 点击Generate Project下载项目压缩包 2. 使用IDEA将解压的项目包以Maven方式导入2.1 解压刚才下载的项目压缩包 2.2 打开IDEA在菜单中选择File -&gt; New -&gt; Project from Existing Sources... 2.3 选择解压的项目文件夹，点击Opne 2.4 点击Import project from external model并选择Maven，点击Finish到底为止。 五、基础项目结构解析 通过上述步骤构建了基础项目，如上图所示： src/main/java下的程序入口：SpringBootDemoApplication src/main/resources下的配置文件：application.properties src/test/下的测试入口：SpringBootDemoApplicationTests 生成的SpringBootDemoApplication和SpringBootDemoApplicationTests类都可以直接运行来启动当前创建的项目，由于目前该项目未配合任何数据访问或Web模块，程序会在加载完Spring之后结束运行。 六、引入Web模块当前的pom.xml内容如下，仅引入了两个模块： spring-boot-starter：核心模块，包括自动配置支持、日志和YAML spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 引入Web模块，需添加spring-boot-starter-web模块： 1234&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 七、编写Hello World服务 创建package命名为net.developerly.web（根据实际情况修改） 创建ExampleController类，内容如下 123456public class ExampleController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125;&#125; 启动主程序，打开浏览器访问http://localhost:8080/hello，可以看到页面输出Hello World]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS项目工程中启动Unity项目工程]]></title>
    <url>%2F2016%2F08%2F30%2FiOS%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E4%B8%AD%E5%90%AF%E5%8A%A8Unity%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、Unity 3D导出iOS项目 将Unity3D 导出 iOS的项目 详细步骤… 导出目录 注）U3D的所有相关设置，都在U3D这边设置，设置好后导出iOS项目 二、将导出的一些文件导入到已有的iOS工程项目中 将Classes 和 Libraries 文件夹 选择 Create groups 方式导入已有的iOS工程中 将Data 文件夹 选择 Create folder references 方式导入的已有的iOS工程中 导入之后的目录结构 三、删除Native下所有的.h文件的引用注意：Native 下面不仅有.h文件，还有.cpp文件，这里只需要删除所有的.h文件四、删除libil2cpp引用五、添加引用类库 添加引用库（有部分是iOS），有三个是optional ~六、Build Settings Build Options -&gt; Enable Bitcode = NO Linking -&gt; Other Linker Flags 添加-weak_framework CoreMotion -weak-lSystem 在Search Paths-&gt;Header Search Paths添加下图中的头文件引用 在Search Paths-&gt;Library Search Paths 添加图中路径 在Apple LLVM 7.1 - Custom Compiler Flags -&gt; Other C Flags 中添加 -DINIT_SCRIPTING_BACKEND=1 同时会在 Other C++ Flags中出现 修改Apple LLVM 7.1 - Language -&gt; C Language Dialect 值改为C99 修改Apple LLVM 7.1 - Language -&gt; Precompile Prefix Header 的值为Yes 在Apple LLVM 7.1 - Language - C++中做如下设置 在Apple LLVM 7.1 - Warnings - Objective C中做如下更改 在User-Defined 中添加如下 GCC_THUMB_SUPPORT = NO GCC_USE_INDIRECT_FUNCTION_CALLS = NO UNITY_RUNTIME_VERSION = 5.4.0f3 UNITY_SCRIPTING_BACKEND = il2cpp七、修改PCH文件 将Unity-&gt;Classes下面的Perfix.pch中的代码全部拷贝到主工程项目的PCH中，并且在主工程项目的PCH中添加 #import &quot;UnityAppController.h&quot; 八、处理主工程和Unity的main文件 处理iOS主工程中的main.m文件，将 .m 改为 .mm 将Unity下Classes下的main.mm文件中的内容拷贝到主工程的main文件中，并进行如下修改： 在Build Phases中移除Unity-&gt;Classes下的main.mm文件九、处理UnityAppController.h文件UnityAppController.h做如下修改 十、处理AppDelegate这个类 在AppDelegate.h中做如下修改 在AppDelegate.m中做如下修改]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>U3D</tag>
        <tag>Unity 3D</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建IPv6本地环境测试App]]></title>
    <url>%2F2016%2F05%2F31%2F%E6%90%AD%E5%BB%BAIPv6%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95App%2F</url>
    <content type="text"><![CDATA[一、前言最近有很多人都在关注支持IPv6的事情，果然是苹果打个哈欠，iOS行业内就得起一次风暴呀。自从5月初Apple明文规定所有开发者在6月1号以后提交新版本必须需要支持IPv6-Only的网络。 二、IPv6-Only支持是什么？IPv6是对IPv4地址空间的扩充，IPv4和IPv6的区别就是IP地址前者是.（dot）分割，后者是以:冒号）分割的（更多详细信息自行搜索）。目前当我们的iOS设备连接上WiFi、4G、3G等网络时，设备被分配的地址均是IPv4，但是随着运营商和企业逐渐部署IPv6 DNS64/NAT64网络之后，设备被分配的地址会变成IPv6的地址，而这些网络就是所谓的IPv6-Only网络，并且仍然可以通过此网络去获取IPv4地址提供的内容。客户端向服务器端请求域名解析，首先通过DNS64 Server查询IPv6的地址，如果查询不到，再向DNS Server查询IPv4地址，通过DNS64 Server合成一个IPv6的地址，最终将一个IPv6的地址返回给客户端。 如图所示： 三、搭建IPv6环境测试你的APP在Mac OS 10.11＋的双网卡的Mac机器（以太网口＋无线网卡），我们可以通过模拟构建这么一个local IPv6 DNS64/NAT64的网络环境去测试应用是否支持IPv6-Only网络，大概原理如下： 搭建IPv6测试环境说白了就是用Mac做一个热点，然后用iPhone连接这个Wi-Fi，听起来很容易，下面跟着我的步伐走吧。（非WiFi上网方式的Mac）和正常的开启Mac热点的方式的区别是这次我们产生的是一个本地的IPv6 DNS64/NAT64网络，这项功能是OS X 10.11新加的功能（如果你的Mac系统版本不是的话必须要升级哦，才能产生IPv6的热点）。和我们以前开启热点方式不一样的地方在于，我们在系统偏好设置（System Preferences）界面选中共享（Sharing）的同时，要按住Option键。见图： 步骤一： 之后在共享界面中，我们会看到和之前不一样的地方，就是红框所标的地方，多了一个叫创建 NAT64 网络 的选框，选中它。 步骤二： 接下来在共享窗口中，依次按图中所示的标号来，如图所示 步骤三： 随后请点击共享以下来源的连接的下拉列表，选择我们想要共享出去的网络接口。我当前是想要共享的是以太网。 PS：如果你的Mac是用有线拨号上网的话，请选择PPOE选项作为共享源。如果你的Mac是用有线上网（不用拨号的）的话，请选择Thunderbolt 以太网有线网选项作为共享源如果使用的是有线的RJ-45接头转USB输出的网络转换工具，请选USB 10/100/1000 LAN。 标号1 标号2：用以下端口共享给电脑 选项此处选择Wi-Fi 标号3：点击Wi-Fi选项...选项，个性化自己的热点的设置 步骤四： 四、大功告成出现以下变化证明你已经成功产生了一个IPv6的热点 Wi-Fi图标变样 看手机的连接共享Wi-Fi的变化普通热点共享 IPv6热点共享 对比2张图中DNS的地址看到区别了吧，一个.分割，一个:分割。 接下来就是测试你的APP是否可以在该WiFi下是否可以访问网络了]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 7.2 真机调试iOS 9.3的设备]]></title>
    <url>%2F2016%2F04%2F13%2FXcode%207.2%20%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95iOS.9.3%E7%9A%84%E8%AE%BE%E5%A4%87%2F</url>
    <content type="text"><![CDATA[前言昨天回到家一不小心把测试机(没有设密码)升级到9.3.1了，立马悲剧了，真机调试时报错：Could not find Developer Disk Image，原因是：Xcode7.2中还没有支持9.3的Disk Image。 iOS 9.3 -&gt; Could not find Developer Disk Image真机调试错误解决办法 将Xcode更新到最新版本7.3，因为支持iOS 9.3的Xcode版本为 7.3（但是Xcode 7.3要求最小系统为10.11，所以这个对于系统还是10.10的没有用）。 下载该Disk Image，放到/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport文件夹下，重启Xcode即可解决此类问题。 资源文件下载地址 对于Xcode老是在App Store升级失败，而且下载慢，我找到了这个－－&gt; 官方Xcode.dmg文件下载链接：超级传送门 Disk Image 9.3 下载地址：http://pan.baidu.com/s/1o7RwhlC]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>真机调试</tag>
        <tag>Disk Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS App上传项目遇到的问题]]></title>
    <url>%2F2016%2F03%2F16%2FiOS%20App%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 提示iTunes Store operation filed（Cannot verify client） 错误原因：没有验证到Itunes Store，网速过慢导致，或者网络堵塞解决办法：找个网络快的地方再试试吧！！ 2. 在上传项目的时候，UpLoad App Store后弹出iTunes Store operation failed 错误原因：你在Itunes Connect（https://itunesconnect.apple.com）网站里没有对应你Xcode项目设置的这个Bundle Id的应用解决办法：去https://itunesconnect.apple.com添加这个应用 3. 这个问题比较麻烦，多半是证书，描述文件Bundle ID不匹配原因！ 错误原因：证书和描述文件不匹配。也就是你选择描述文件（而描述文件绑定的证书不是你机器上的证书）解决办法：让证书自动去寻找描述文件。看下图 如果还不行，就确认下你的证书和描述文件 是否真正对应上了! 4. Itunes Store operation failed 解决方法：重新启动Xcode完全退出。 5. Archive是灰色的，不能选择 6. 错误：二进制文件无效（构建版本无效）的问题 错误原因：可能是你工程里有问题。解决办法：看看你当初注册申请的App ID绑定的邮箱，因为你这个构建版本有问题的时候，苹果公司会给你发个邮件（里面会详细说明你的问题）不过百分之50都是百度地图的问题 需要在这里添加-ObjC要注意大小写 -Objc作用是：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中。 7. 用Xcode直接上传App Store出现如下图错误：（之前是用Xcode6.4上传的，提交了n次都报这个错） 解决办法：用Xcode7上传就不会包这个错误了，所以大家遇到这个问题，直接用Xcode7以上的版本提交。 8. 上传iTunes报下面错误 解决办法： 9. 打包时遇见的错误–App配置为iOS路由App要将App配置为iOS路由App，请在iTunes Connect的我的App中的App版本页面上传App地区范围文件 解决办法： 把Map关掉! 10. iOS此证书的签发者无效上传App报错,如图: 解决办法： 下载https://developer.apple.com/certificationauthority/AppleWWDRCA.cer的证书，然后双击安装。 在钥匙串里选择登录,然后点选证书，在这个界面，选择工具栏的View -&gt;显示过期证书(Show Expired Certificates)，这时候你会发现一个过期的(Apple Worldwide Developer Relations Certification Authority），删除它。 在系统(System)的那一栏也有这个过期的WWDR Certificate，一并删除它。 不出意外你的证书那里从This certificate has an invalid issuer（此证书的签发者无效）变成了This certificate is valid了。 11. 上传时遇到以下错误 解决方法： 很简单Xcode -&gt; Product -&gt; Clean，然后重新打包！ 12. 将App上传到App Store的时候通常会遇到这个问题 解决方法： 很多人说苹果那边服务器问题，重复尝试几次，总会成功的！不过我还是推荐用Application Loader上传，成功率就非常高。如果Application Loader也不行，需要检查下自己的网络，有时候VPN也会提高速度（不行就等一段时间试试）。 其他 iOS Xcode 打包IPA问题集锦 ###还有什么问题？欢迎大家补充… 以上部分有转载网络其它文章，如果原作者有意见，可以联系我删除。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AppStore</tag>
        <tag>App上传</tag>
        <tag>UpLoad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS App上架流程（2016详细版）]]></title>
    <url>%2F2016%2F03%2F15%2FiOS%20App%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B(2016%E8%AF%A6%E7%BB%86%E7%89%88)%2F</url>
    <content type="text"><![CDATA[一、前言：作为一名iOSer，把开发出来的App上传到App Store是必要的。下面就来详细讲解一下具体流程步骤。 二、准备： 一个已付费的开发者账号（账号类型分为个人（Individual）、公司（Company）、企业（Enterprise）、高校（University）四种类型，每年资费分别为$99、$99、$299、免费。）。 一个已经开发完成的项目。 三、检查： 你的Xcode必须是正式版的，beta版本的Xcode是不能上传项目的。 上传使用的Mac的OS X系统必须也是正式版的，beta版本也不行。 请确认你安装的Xcode是从App Store或者是开发者网站下载的，而不是从其它渠道获取的安装包安装的,因为非官方途径下载的Xcode可能带有XcodeGhost病毒。如何检查？ 四、生成发布证书1. 打开苹果开发者中心：https://developer.apple.com打开后点击：Account 下面输入已付款过的Apple账号和密码登录（如果你的电脑已经保存了密码，会直接进入） 2. 点击：Certificates, Identifiers &amp; Profiles (专门生成证书，绑定Bundle Id，绑定device设备，生成描述文件的地方) 3. 点击Certificates生成证书 选择iOS, tvOS, watchOS 选择All 点击右上角新添加证书 4. 由于是做App上传，选择生产证书（选择App Store and Ad Hoc） 注意： 一个开发者账号只能创建（1-2个开发（测试）证书，2-3个生产（发布）证书），如果你的App Store Ad Hoc前面的按钮不能选择，则代表你的这个账号无法再创建新的生产证书了。 解决方法： 从共同使用这个账号的人电脑上生成.p12文件，导入自己的电脑。（尽量不要执行下面第2步） 如果你想生成的话，把现有的删除一个（建议删除时间比较靠前的）。注意：如果删除一个证书，那么正在使用这个证书的人将不能再使用了，除非重新生成，然后利用.p12重新导入自己的电脑里！ 注意：如果你想删除证书，执行下面步骤，否则略过。 然后接上上图，生产证书部分继续 5. 上传CSR文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）1. 在Launchpad的其他里面，点击钥匙串访问弹出如下界面 2. 工具栏选择钥匙串访问-&gt;证书助理-&gt;从证书颁发机构请求证书… 3. 将CSR文件保存到MAC磁盘的某个位置（这里我选择的是桌面，进行存储） 6. 然后回到浏览器，点击Choose File... 7. 选择创建好的：CertificateSigningRequest.certSigningRequest文件，点击选取 点击Generate上传证书 8. 跳转到如下界面，点击 DownLoad 下载生成的证书（cer后缀的文件），然后点击Done，你创建的发布证书就会存储在帐号中。 注意：这个证书只能下载一次。点击下载后，关闭页面后就不能再回到下载页面了。如果不需要给别的电脑使用，则直接跳过下面附加项，跳转到第五步（绑定Bundle Identifier） 附加项：生成p12文件在其他电脑上使用这个发布证书1. 双击安装证书后，打开钥匙串访问，选择安装的证书右键单击 注意：如果没有导出，可以把这个证书删除，然后重新双击下载的证书文件安装。 2. 导出证书 3. 存储证书 注意：存储的文件格式一定要是.p12 4. 设置密码可以为证书设置密码，也可以不设置密码；如果设置了密码，那么别人安装这个证书的时候就要输入密码，否则无法安装。这里就不设置密码了。 5. 保存导出的证书 如果需要在其它电脑上也能发布App,那么就必须要安装这个发布证书。 五、创建App IDs和绑定你的App的Bundle Identifier回到刚才的页面：https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action 1. 点击App IDs,进入如下界面，点击右上角的 + 号 2. 填写App IDs和Bundle Identifier 注意： 上传App使用的Bundle Identifier(不要有-，都是英文+数字)必须是固定的，不能使用占位符。 如果你的Bundle Identifier已经在网站上绑定了，如果你又修改了你工程里面这个Bundle Identifier的话，需要重新进入到开发者账号里面绑定。 下面选择App中包含的服务，默认有两项，其余的根据自己项目的需求进行选择 3. 点击Continue 4. 点击Register 5. 点击Done 六、生成描述文件（描述文件的作用就是把证书和Bundle Identifier关联起来）1. 找到Provisioning Profiles ，点击All，然后点击右上角 + 号 2. 因为是发布，所以选择下面App Store这个描述文件，点击Continue 3. 在App ID这个选项栏里面找到你刚刚创建的：App IDs（Bundle Identifier）类型的套装，点击Continue 4. 选择你刚创建的发布证书（或者生成p12文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击Continue 5. 在Profile Name栏里输入一个名字（这个是Provisioning Profiles文件的名字，可随便输入，在这里我用工程名字，便于分别），然后点击Generate 6. Download生成的Provisioning Profiles文件，然后点击Done，双击安装（闪一下就完事了，没其它效果） 六、在App Store开辟空间1. 回到Member Center，点击iTunes Connect 2. 登录开发者账号（还是之前已付费的账号） 3. 登录成功后，点击我的App 4. 点击左上角那个＋号，点击新建(注意：我们是iOS App开发，不要选Mac App啦） 5. 依次按提示填入对应信息（SKU是公司用于做统计数据之类的id，根据公司需求填写），然后点击创建 注意：如果都填好以后，可能会告诉你，你的App名称已经被占用，那么不好意思，你只能改名了！（而且建议大家起名不要往比较出名的App上靠，否则审核可能会被拒绝） 6. 填写App其它信息 7. 填写价格和销售范围（由于我的开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费） 8. 依次把不同尺寸的App截图拉入到对应的里面需要填写不同尺寸的手机屏幕截图（也就是拿不同尺寸的模拟器运行后，挑出至少3页最多5页进行截图然后拖到响应的区里）（在模拟器Command + S就可以保存屏幕截图到桌面了）（注意：如果提示拖进去的图片尺寸不对，则把模拟器弄成100%然后再Command + S ) 尺寸参照表在下面 尺寸参照图： 9. 填写App简介 10. 按提示依次输入 错误提示：如果上传App图标失败，提示Alpha错误的话，看下面。 打开你的图标图片，勾掉这个 11. 点击分级后面的编辑，如实填写后，点击完成 12. 填写审核信息 版本发布就是：（然后最下面选择自动发布的话就是如果审核通过，就自动上传到App Store供人下载） 13. 此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入Xcode中把项目打包发送到过来。注意：填写完一定要点击右上角的保存。 七、在Xcode中打包工程找到你刚刚下载的发布证书（后缀为.cer）或者p12文件，和PP文件，双击，看起来没反应，但是他们已经加入到你的钥匙串中。 1. 在Xcode中选择iOS Device(这里不能选择模拟器)，按照下图提示操作 2. 如果你的应用不支持横屏，把这两个勾去掉 3. 查看版本号和构建版本号 4. 配置发布证书(ps:截图时选择的证书是错误的，大家注意一下，要选择发布证书) 注意：如果这里没有黄色叹号，代表你的配置没问题，如果有，那就是证书和描述文件不匹配，或者描述文件里刚才选的Bundle和现在的工程的Bundle Identifier不一致，去 https://develop.apple.com 上找到你的描述文件在确认下绑定的bundle Identifier和你工程是不是一样的？ 5. 将断点、全局断点，僵尸模式等都要去掉。 6. 设置Release模式（Debug是测试的，Release是发布用的） 7. 选择Xcode下Product下Archive（专门用于传项目，或者打包项目） 8. 出现下图说明你没有添加开发者账号，点击右下脚Add...按钮就可以添加 9. 输入付费的开发者账号 可能会弹出下面这个界面，如果不弹出，按Command加。 10. 然后回到Archive(选择已付费的账号)，然后点击Choose 然后等待 11. 选择Upload提交 12. 如下就代表上传成功，如果出错，请参照iOS App上传项目遇到的问题 13. 返回Itunes Connect网站上你自己的App信息中查看一下 14. 在这个构建版本这里就可以添加代码 点击＋号之后选择代码版本 15. 提交以供审核 16. App已经从准备提交，变成正在等待审核状态 17. 等待苹果的审核…八、补充构建版本的方法有两种，一种是使用Xcode(上面已经介绍了)，另一种就是使用一个叫Application Loader这个软件： 使用Xcode构建版本：上面已经介绍（已经Archive的话，可以在Xcode: Window -&gt; Organizer进入） 使用Application Loader构建版本： 如上图，点击Export...，导出一个ipa文件（ps:为了保险起见、让苹果审核顺利一点，这里可以先点击Validate...来验证一下，这里就懒得验证了） Application Loader下载Xcode的时候就已经下载了（没有的请自行下载），Xcode右键弹出下面界面 打开Application Loader（如果没有登录，会提示你登录你的开发者账号） 选取你导出的ipa文件（或者双击交付您的应用程序选取ipa文件），之后按提示操作就行，上传完毕没有报错的话，过几分钟左右就可以在iTunes Connect里面就可以看到你上传的这个版本了。 补充就这些吧，后面遇到再补充吧！个人建议构建版本使用Application Loader上传，成功率更高！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AppStore</tag>
        <tag>App上架</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题总结整理（附答案-持续更新）]]></title>
    <url>%2F2016%2F03%2F13%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86%EF%BC%88%E9%99%84%E7%AD%94%E6%A1%88-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 多线程的实现方式； 2. 延迟执行的几种方式； 延迟1秒执行代码 123-(void)delayMethod&#123; NSLog(@&quot;delayMethodEnd&quot;);&#125; performSelector方法: 123// 此方式要求必须在主线程中执行，否则无效。// 是一种非阻塞的执行方式，暂时未找到取消执行的方法。[self performSelector:@selector(delayMethod) withObject:nil afterDelay:1.0f]; 定时器：NSTimer; 123// 此方式要求必须在主线程中执行，否则无效。// 是一种非阻塞的执行方式，可以通过`NSTimer`类的`- (void)invalidate;`取消执行。[NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(delayMethod) userInfo:nil repeats:NO]; sleep方式； 123// 此方式在主线程和子线程中均执行。// 是一种阻塞的执行方式，`建议放到子线程中，以避免卡住界面`，没有找到取消执行的方法。[NSThread sleepForTimeInterval:1.0f]; [self delayMethod]; GCD方式 1234567// 此方式可以在参数中选择执行的线程。// 是一种非阻塞的执行方式，// 没有找到取消执行的方式。__weak id safeSelf = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [safeSelf delayMethod];&#125;); 3. App崩溃的情况有多少种；1. 违反操作系统规则：比如启动恢复挂起退出时`watchdog`超时，用户强制退出或者低内存终止。 2. 应用程序异常退出。 4. 你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？参考答案： Objecitve-C的重要特性是Runtime（运行时）,在#import &lt;objc/runtime.h&gt; 下能看到相关的方法，用过objc_getClass()和class_copyMethodList()获取过私有API; 使用Objecitve-C Method method1 = class_getInstanceMethod(cls, sel1); Method method2 = class_getInstanceMethod(cls, sel2); method_exchangeImplementations(method1, method2); 代码交换两个方法，在写unit test时使用到。 5. 对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？参考答案： 最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲突，可以使用长命名法或特殊前缀解决，如果是引入的第三方库之间的命名冲突，可以使用link命令及flag解决冲突。 6. iOS中的几种传值问题？ 顺传一般是直接传值 代理传值 123456789101112131415A&lt;B-Delegate&gt; // A实现B协议B // 声明协议和方法 声明代理属性Delegate-&gt;(methodFromB:(B)b value:(obj)obj)// B声明协议方法property-weak-deleagte // 在A中B.delegate = A; // 当B中发生传值时调用B[self.delegate methodFromB:self value:obj] // 因为 self.delegate = A// A中执行定义的协议方法接收到值-methodFromB:(B)b value:(obj)obj Block传值 12345678910111213A// A中实现B的block的代码块B.block = ^(obj)&#123; &#125;;B // 声明代码块typedef BBlockproperty-block// 当B中调用self.block(obj);就会调用A中以实现的代码块实现传值 通知传值 1234567A中接收通知NotificationCenter.addobserve(A).name(&quot;NAME&quot;).selector(noti:)-noti:(noti)noti&#123; noti.obj// 接收到值&#125;B中发送通知NotificationCenter.postName(&quot;NAME&quot;).obj(obj) 单例传值 1234// 用单例中的值更新A的值A.property = global.singleton.property;// B中值改变 把值赋给单例global.singleton.property = B.property; 7. 什么是 ARC? (ARC 是为了解决什么问题而诞生的?) ARC 是 Automatic Reference Counting 的缩写, 即自动引用计数. 这是苹果在 iOS5 中引入的内存管理机制. Objective-C 和 Swift 使用 ARC 追踪和管理应用的内存使用. 这一机制使得开发者无需键入 retain和 release, 这不仅能够降低程序崩溃和内存泄露的风险, 而且可以减少开发者的工作量, 能够大幅度提升程序的流畅性和可预测性. 但是 ARC 不适用于 Core Foundation 框架中, 仍然需要手动管理内存. 8. 以下 keywords 有什么区别: assign vs weak ,__block vs __weakassign 和 weak是用于在声明属性时, 为属性指定内存管理的语义. assign 用于简单的赋值, 不改变属性的引用计数, 用于 Objective-C 中的 NSInteger , CGFloat 以及 C 语言中 int , float , double 等数据类型. weak 用于对象类型, 由于 weak 同样不改变对象的引用计数且不持有对象实例, 当该对象废弃时, 该弱引用自动失效并且被赋值为 nil , 所以它可以用于避免两个强引用产生的循环引用导致内存无法释放的问题. __block 和 __weak 之间的却是确实极大的, 不过它们都用于修饰变量. 前者用于指明当前声明的变量在被 block 捕获之后, 可以在 block 中改变变量的值. 因为在 block 声明的同时会截获该 block 所使用的全部自动变量的值, 而这些值只在 block 中只具有”使用权”而不具有”修改权”. 而 __block 说明符就为 block 提供了变量的修改权. 后者是所有权修饰符, 什么是所有权修饰符? 这里涉及到另一个问题, 因为在 ARC 有效时, id 类型和对象类型同 C 语言中的其他类型不同, 必须附加所有权修饰符. 所有权修饰符一种有 4 种: __strong __weak __unsafe_unretained __autorelease __weak 与 weak 的区别只在于, 前者用于变量的声明, 而后者用于属性的声明. 9. __block 在 ARC 和非 ARC 下含义一样吗？__block 在 ARC 下捕获的变量会被 block retain, 这样可能导致循环引用, 所以必须要使用弱引用才能解决该问题.而在非 ARC 下, 可以直接使用 __block 说明符修饰变量, 因为在非 ARC 下, block 不会 retain 捕获的变量. 10. viewWillLayoutSubviews 的作用是什么? viewWillLayoutSubviews 方法会在视图的 bounds 改变时, 视图会调整子视图的位置, 我们可以在视图控制器中覆写这个方法在视图放置子视图前做出改变, 当屏幕的方向改变时, 这个方法会被调用. 11. SDWebImage 里面给 UIImageView 加载图片的逻辑是什么样的?我曾经阅读过 SDWebImage 的源代码, 就在这里对如何给 UIImageView 加载图片做一个总结吧, SDWebImage 中为 UIView 提供了一个分类叫做 WebCache, 这个分类中有一个最常用的接口, sd_setImageWithURL:placeholderImage: , 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 option progressBlock completionBlock的方法, 而在这个类最终被调用的方法首先会检查是否传入了 placeholderImage 以及对应的参数, 并设置 placeholderImage .然后会获取 SDWebImageManager 中的单例调用一个 downloadImageWithURL:... 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以 url 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 MD5 处理过的 key 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一 个 SDWebImageDownloader 对象的方法 downloadImageWithURL:... 来下载图片, 这个方法会在执行的过程中调用另一个方法 addProgressCallback:andCompletedBlock:fotURL:createCallback: 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 NSMutableURLRequest 和 SDWebImageDownloaderOperation , 并将后者加入 downloader 持有的下载队列开始图片的异步下载.而在图片下载完成之后, 就会在主线程设置 image, 完成整个图像的异步下载和配置. 12. 你一般是怎么用Instruments的？（工作经验的问题，没必要所有都答）参考答案： 使用Allocations来检测内存和堆栈信息 使用Leaks检测内存的使用情况，包括内存泄露问题 使用Zombies来检测过早释放的僵尸对象，通过它可以检测出在哪里崩溃的。 使用Time Profiler来检测CPU内存使用情况，性能分析 13. performSelector:withObject:afterDelay:内部大概是怎么实现的，有什么注意事项么？ 创建一个定时器,时间结束后系统会使用runtime通过方法名称(Selector本质就是方法名称)去方法列表中找到对应的方法实现并调用方法 注意事项 调用performSelector:withObject:afterDelay:方法时,先判断希望调用的方法是否存在respondsToSelector: 这个方法是异步方法,必须在主线程调用,在子线程调用永远不会调用到想调用的方法 14. 有哪些常见的 Crash 场景？ 访问了僵尸对象 访问了不存在的方法 数组越界 在定时器下一次回调前将定时器释放,会Crash 持续更新…]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点击状态栏，滚动视图返回顶部的实现原理]]></title>
    <url>%2F2016%2F02%2F27%2F%E7%82%B9%E5%87%BB%E7%8A%B6%E6%80%81%E6%A0%8F%EF%BC%8C%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、前言 在iOS开发中，我们常常看到好多应用都有这样一个效果，如果一个应用当前页是是一个滚动视图，当用户点击状态栏的时候，滚动视图会自动的返回内容的最顶部。其实这个功能是UIScrollView自带的，不需要我们手动去实现，只需要设置self.scrollView.scrollsToTop = YES即可（scrollsToTop默认为YES）。但是这个属性有一个前提是窗口下必须只有一个可滚动的View才有效果。 12// When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top, but only if its `scrollsToTop` property is YES, its delegate does not return NO from `shouldScrollViewScrollToTop`, and it is not already at the top.// On iPhone, we execute this gesture only if there&apos;s one on-screen scroll view with `scrollsToTop` == YES. If more than one is found, none will be scrolled. 在实际应用中，我们可能会有多个scrollView（包含UITableView/UICollectionView），如网易新闻、爱奇艺，腾讯视频等等应用，这时候，系统默认的点击状态栏返回到顶部效果就会失效，原因是当前window下多个scrollView的scrollsToTop属性的值都是YES,系统不知道该让哪一个scrollView滚动到顶部，所以就什么也不干了。如果还要让当前视图滚回顶部，只需要将除了当前显示的其它scrollView的scrollsToTop属性设置成NO就行。 但是今天要讲的是应网友要求，讲一下自定义控件来实现此功能。就是《LYTopWindow》实现原理。 二、基本思路 获取当状态栏的点击事件 取得当前window上显示的scrollView 控制scrollView的偏移量，让其滚动到顶部 三、实现步骤新建一个空白项目，我们可以查看应用结构可以知道，状态栏是独立出来的，并不在window上 所以我们不能拿到状态栏直接操作，那么就需要自定义一个控件盖在状态栏上面，用来拦截状态栏的点击事件。 一、添加窗口由于添加普通的控件都不能盖在状态栏上面，所有要新建一个普通的window（keyWindow只能有一个）盖到状态栏的上面。 在AppDelegate创建一个新的窗口,从iOS9.0开始，程序启动结束时的窗口都必须设置rootViewController。否则会报以下错误： 1Application windows are expected to have a root view controller at the end of application launch 这里可以通过dispatch_after来给添加窗口一个延时就可以不设置根控制器而不会报错 UIWindow的显示不需要添加到其它控件上，只需要将hidden设置成NO就行。 要想让自定义窗口盖在状态栏的上面还要设置窗口的级别windowLevel，窗口的级别有三种，分别是UIWindowLevelAlert &gt; UIWindowLevelStatusBar &gt; UIWindowLevelNormal，级别越高就越显示在顶部，如果级别一样，那么后创建添加的显示在顶部。 1234567891011static UIWindow *topWindow_;-(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; topWindow_ = [[UIWindow alloc] init]; topWindow_.frame = [UIApplication sharedApplication].statusBarFrame; topWindow_.backgroundColor = [UIColor clearColor]; topWindow_.hidden = NO; topWindow_.windowLevel = UIWindowLevelAlert; &#125;); return YES;&#125; 然后在给topWindow添加一个手势监听点击事件就可以拦截到状态栏的点击事件了。但是，这样写会有一个Bug,如果旋转屏幕的话，window上的添加的View的frame不会跟着屏幕旋转而改变，就会不正确。 如果需要屏幕旋转的话，必须要给UIWindwo设置rootViewController； Bug产生的原因是Autoresizing的影响，在旋转的屏幕时，窗口的View宽高被拉伸而造成frame不正确，这时只需要设置一下View跟随窗口的变化而变化即可。 1topWindow_.rootViewController.view.autoresizingMask = UIViewAutoresizingFlexibleWidth; 居然这里已经设置了rootViewController，那么就不需要dispatch_after。 12345678910static UIWindow *topWindow_;-(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; topWindow_ = [[UIWindow alloc] init]; topWindow_.frame = [UIApplication sharedApplication].statusBarFrame; topWindow_.backgroundColor = [UIColor clearColor]; topWindow_.hidden = NO; topWindow_.windowLevel = UIWindowLevelAlert; [topWindow_ addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(topWindowClick)]]; return YES;&#125; 二、监听顶部窗口点击，实现当前滚动视图滚回顶部12345/** * 监听顶部窗口点击 */+ (void)topWindowClick &#123; UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow; [self searchAllScrollViewsInView:keyWindow];&#125; 查找当前keyWindow上的滚动视图,如果跟keyWindow重叠，就让其滚动到顶部 12345678910111213141516171819202122/** * 查找view中的所有scrollView */- (void)searchAllScrollViewsInView:(UIView *)view &#123; // 如果不在UIWindow矩形框里面，就直接返回 // view和UIWindow没有重叠，就直接返回 if (![view intersectWithView:nil]) return; for (UIView *subview in view.subviews) &#123; [self searchAllScrollViewsInView:subview]; &#125; // 如果不是UIScrollView, 直接返回 if (![view isKindOfClass:[UIScrollView class]]) return; UIScrollView *scrollView = (UIScrollView *)view; // 让UIScrollView滚动到最前面 CGPoint offset = scrollView.contentOffset; offset.y = - scrollView.contentInset.top; [scrollView setContentOffset:offset animated:YES];&#125; LYTopWindow的基本实现原理就是这样了，如果想看了解基本实现步骤可以查看LYTopWindow的源代码：https://github.com/DeveloperLY/LYTopWindow 。 三、补充如果使用了自定义控件实现了点击状态栏滚动视图自动滚回顶部，那么控制器的这两个方法会失效： 控制器的- (BOOL)prefersStatusBarHidden方法决定状态栏的可见性 控制器的- (UIStatusBarStyle)preferredStatusBarStyle方法决定状态栏的样式 原因就是状态栏的样式\可见性，由最顶层（盖在最上面）window的控制器来决定所以如果使用了LYTopWindwo框架的，如果要控制状态栏的样式和可见性可以使用下面的代码： 1234567// 可见性[LYTopWindow sharedTopWindow].statusBarHidden = NO;[LYTopWindow sharedTopWindow].statusBarHidden = YES; // 样式[LYTopWindow sharedTopWindow].statusBarStyle = UIStatusBarStyleDefault;[LYTopWindow sharedTopWindow].statusBarStyle = UIStatusBarStyleLightContent;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIScrollView</tag>
        <tag>LYTopWindwo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行代码集成点击状态栏，滚动视图当前内容滚动到顶部]]></title>
    <url>%2F2016%2F02%2F22%2F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%9B%86%E6%88%90%E7%82%B9%E5%87%BB%E7%8A%B6%E6%80%81%E6%A0%8F%EF%BC%8C%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E5%BD%93%E5%89%8D%E5%86%85%E5%AE%B9%E6%BB%9A%E5%8A%A8%E5%88%B0%E9%A1%B6%E9%83%A8%2F</url>
    <content type="text"><![CDATA[只有一个ScrollView的时候我们在使用App的时候，经常会看到这样的效果，当我们点击状态栏的时候，我们已经滚动过的内容，会自动的滚回顶部，例如：设置界面: 其实这个功能是系统默认实现的，不需要自己写代码。当点击状态栏的时候自动滚回顶部是因为UIScrollView的scrollsToTop的属性为YSE 1@property(nonatomic) BOOL scrollsToTop __TVOS_PROHIBITED; // default is YES. 居然系统已经实现了这个功能，那么为什么还要自己实现呢？这个是因为，系统实现的是有缺陷的。 当ScrollView超过一个的时候下面是苹果对scrollsToTop属性的解析说明 12// When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top, but only if its `scrollsToTop` property is YES, its delegate does not return NO from `shouldScrollViewScrollToTop`, and it is not already at the top.// On iPhone, we execute this gesture only if there&apos;s one on-screen scroll view with `scrollsToTop` == YES. If more than one is found, none will be scrolled. 那就是当前视图下，超过一个ScrollView的时候，即使你将scrollsToTop的值设置为YES，但是在点击状态栏的时候，不会有一个ScrollView会滚动到顶部。 这个时候，如果我们需要这个功能，那么就要我们手动实现了。针对这个，我封装了一个小框架“一行代码完成“点击状态栏滚动视图当前内容滚动到顶部”，框架集成了CocoaPods，方便使用，一行代码可以实现这个小功能。 使用LYTopWindow第一步：使用CocoaPods导入LYTopWindow在 Podfile 中进行如下导入： 1pod &apos;LYTopWindow&apos; 然后使用 cocoaPods 进行安装： 如果尚未安装CocoaPods, 运行以下命令进行安装: 1gem install cocoapods 安装成功后就可以安装依赖了： 建议使用如下方式： 12# 禁止升级CocoaPods的spec仓库，否则会卡在 Analyzing dependencies ，非常慢 pod update --verbose --no-repo-update 如果提示找不到库，则可去掉--no-repo-update 1pod update 第二步：集成点击状态栏当前内容滚动到顶部导入头文件 1#import &lt;LYTopWindow.h&gt; 在AppDelegate.m中方法application:didFinishLaunchingWithOptions:中添加以下代码 123456[[LYTopWindow sharedTopWindow] setClickStatusBarBlock:^&#123; // 让keyWindow上的ScrollView滚动到顶部 [[LYTopWindow sharedTopWindow] searchAllScrollViewsInView:[UIApplication sharedApplication].keyWindow]; // 如果需要实现点击状态栏，实现其他功能，可用在这里编写功能代码&#125;]; 注意：如果需要实现其他功能效果，可以将这句代码替换成其他需要的代码 1[LYTopWindow sharedTopWindow] searchAllScrollViewsInView:[UIApplication sharedApplication].keyWindow]; 框架里面有个小Demo，可以自行实验，欢迎IssuesLYTopWindow地址：https://github.com/DeveloperLY/LYTopWindow如果想了解LYTopWindow的实现原理，可以查看我的另一篇文章《点击状态栏，滚动视图返回顶部的实现》]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIScrollView</tag>
        <tag>scrollsToTop</tag>
        <tag>LYTopWindow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Xcode添加删除当前行、复制当前行快捷键]]></title>
    <url>%2F2016%2F01%2F18%2F%E4%B8%BAXcode%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E8%A1%8C%E3%80%81%E5%A4%8D%E5%88%B6%E5%BD%93%E5%89%8D%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[之前在做JAVA开发时,使用eclipse过程中,用的最多也是特喜欢的就是删除当前行和复制当前行的快捷键。然而在转向iOS开发时,Xcode是不支持这两个快捷键的,一次偶然发现有个小窍门可以为Xcode来添加这两个快捷键。 修改权限 修改Xcode里快捷键的配置文件(plist)的权限,在终端中输入下面两条命令 12sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plistsudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/ 添加快捷方式 权限修改完成后,在终端中输入下面的命令,打开plist文件修改(默认是Xcode打开) 1open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist 添加删除当前行 找到root下的Deletions,在Deletions下添加一个item: key:Delete Current Line value:deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine: 添加复制当前行 在Insertions and Indentations下添加两个item: key:Duplicate Current Line value:selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward: key:Insert Line Under value:moveToEndOfLine:, insertNewline: 如图 设置快捷键 最重要的部分来了, 重启Xcode, 然后在preferences里找到Key Bindings,在搜索框中输入current,可以快速定位到Delete Current Line和Duplicate Current Line两个选项,只要设置自己喜欢的快捷键即可。 如图:]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吱一声]]></title>
    <url>%2F2016%2F01%2F16%2F%E5%90%B1%E4%B8%80%E5%A3%B0%2F</url>
    <content type="text"><![CDATA[想我也不是那种写博客的人(很久以前CSDN地址)，但作为一枚程序猿没有个自己的博客，貌似很OUT~~。 博客是部署到GitHub上的，用的是Hexo，很方便就搭起来了~ 只是存在的时间有多长，就不得而知啦~~]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
